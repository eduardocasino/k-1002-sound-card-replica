   
;        COPYRIGHT 1977 BY MICRO TECHNOLOGY UNLIMITED, BOX 4596,
;        MANCHESTER, NEW HAMPSHIRE 03108
;        PROGRAM WRITTEN BY HAL CHAMBERLIN

;        FOURIER SERIES EVALUATION PROGRAM FOR COMPUTING WAVEFORM TABLE
;        CONTENTS FROM HARMONIC SPECIFICATIONS.

;        ENTER AT SCALE TO COMPUTE ONE CYCLE OF A WAVEFORM SUITABLE FOR
;        USE WITH EITHER THE SIMPLIFIED 4 VOICE MUSIC INTERPRETER, THE
;        ADVANCED 4 VOICE MUSIC INTERPRETER, OR THE SIMPLIFIED SINGLE
;        VOICE MUSIC INTERPRETER WITH EXPRESSION.  ENTER AT WAVE TO
;        BYPASS SCALE FACTOR COMPUTATION (USER MUST SUPPLY SCALE FACTOR)

;        THE "FOURIER SERIES SPECTRUM PARAMETERS" MUST BE SET TO
;        APPROPRIATE VALUES BEFORE EXECUTING THE PROGRAM.

;        WAVEAD   ADDRESS OF WAVEFORM TABLE TO FILL.  THE ROUTINE
;                 COMPUTES 256 SAMPLES ON ONE CYCLE OF THE WAVEFORM AND
;                 PLACES THEM IN MEMORY STARTING AT THE CONTENTS OF
;                 WAVEAD.
;        PKAMP    THE WAVEFORM RESULTING FROM THE FOURIER SERIES
;                 EVALUATION IS NORMALIZED SUCH THAT THE NEGATIVE PEAK
;                 IS EQUAL TO ZERO AND THE POSITIVE PEAK IS EQUAL TO
;                 PKAMP.  NORMALIZATION CAN BE BYPASSED FOR NON-AUDIO
;                 APPLICATIONS.
;        NHARM    SET EQUAL TO THE HIGHEST HARMONIC TO GENERATE.  THE
;                 ROUTINE WILL IGNORE FSRAM ENTRIES CORRESPONDING TO
;                 HARMONICS HIGHER THAN NHARM AND THUS WILL RUN FASTER.
;        FSRAM    A TABLE OF HARMONIC AMPLITUDES AND PHASES.  EACH
;                 HARMONIC IS REPRESENTED BY A PAIR OF BYTES.  THE FIRST
;                 BYTE OF THE PAIR IS THE AMPLITUDE OF THE CORRESPONDING
;                 HARMONIC.  THIS IS AN UNSIGNED BINARY FRACTION; X'FF
;                 IS MAXIMUM (.996), X'80 = .5, X'40 = .25, ETC.  THE
;                 SECOND BYTE IS THE PHASE ANGLE OF THE CORRESPONDING
;                 HARMONIC EXPRESSED AS AN UNSIGNED BINARY FRACTION
;                 MULTIPLIED BY 2*PI RADIANS; 0 = NO PHASE SHIFT (COSINE
;                 WAVE), X'40 = PI/2 RADIAN SHIFT = 90 DEGREES, ETC.
;                 THE FIRST BYTE PAIR CORRESPONDS TO THE ZEROTH HARMONIC
;                 (DC COMPONENT), NEXT PAIR TO THE FUNDAMENTAL, NEXT TO
;                 THE SECOND HARMONIC, ETC.  NOTE THAT THE NORMALIZATION
;                 PROCESS DESTROYS ANY EFFECT OF THE DC COMPONENT ON THE
;                 RESULTING WAVEFORM.  IN NON-AUDIO APPLICATIONS
;                 NORMALIZATION MAY BE BYPASSED AND THUS THE DC
;                 COMPONENT WILL BE EFFECTIVE.  THE PHASE OF THE DC
;                 COMPONENT SHOULD BE ZERO FOR THE EXPECTED RESULTS.

;        NOTE THAT WHEN USING THIS PROGRAM TO COMPUTE WAVEFORMS FOR THE
;        MUSIC PROGRAMS THAT THE HIGHEST NON-ZERO HARMONIC OF THE
;        HIGHEST NOTE PLAYED BY A VOICE USING THE WAVEFORM SHOULD NOT BE
;        GREATER THAN 4.5 TO 5.0 KHZ.  IF THIS CONDITION IS NOT MET, THE
;        UPPER HARMONICS WILL ALIAS AND CREATE A VERY HARSH SOUND.  IN
;        SYSTEMS WITH ADEQUATE MEMORY FOR SEPARATE WAVEFORM TABLES, THE
;        LOWER REGISTER VOICES MAY BE SEPARATED FROM THE HIGHER REGISTER
;        ONES AND GIVEN A RICHER HARMONIC SPECTRUM.

;        NOTE THAT THIS PROGRAM CONTAINS SOME GENERALLY USEFUL
;        ARITHMETIC SUBROUTINES FOR DOUBLE PRECISION MULTIPLY AND
;        DIVIDE.

         .zeropage           ; KEEP ALL CONSTANTS AND DATA IN PAGE 0

KIMMON   =      $1C22        ; ENTRY POINT TO KIM KEYBOARD MONITOR
WAVETB   =      $0300        ; ADDRESS OF WAVEFORM TABLE IN SIMPLIFIED
                             ; 4 VOICE MUSIC PROGRAM
DAC      =      $1700        ; OUTPUT PORT ADDRESS WITH DAC
DACDIR   =      $1701        ; DATA DRIECTION REGISTER FOR DAC PORT
PTB      =      $1702        ; PORT 8 ON APPLICATION CONNECTOR
PTBDIR   =      $1703        ; DATA DIRECTION REGISTER FOR PORT B

;        STORAGE FOR THE ARITHMETIC SUBROUTINES

PROD:    .WORD  0,0          ; PRODUCT/DIVIDEND FOR ARITHMETIC ROUTINES
MPCD:    .WORD  0            ; MUPTIPLICAND/DIVISOR FOR ARITHMETIC
MPSAVE:  .WORD  0            ; TEMPORARY STORAGE FOR MULTIPLY
DVND     =      PROD         ; EQUATES FOR DIVISON ROUTINES
DVSR     =      MPCD

;        STORAGE FOR THE FOURIER SERIES EVALUATION

HRMACC:  .WORD  0            ; HARMONIC ACCUMULATOR
PNTNO:   .BYTE  0            ; POINT NUMBER WITHIN CYCLE OF WAVE
NDXACC:  .BYTE  0            ; INDEXING ACCUMULATOR
HRMCNT:  .BYTE  0            ; HARMONIC COUNTER
MAX:     .WORD  0            ; MAXIMUM WAVEFORM AMPLITUDE
MIN:     .WORD  0            ; MINIMUM WAVEFORM AMPLITUDE
SCALEF:  .WORD  0            ; SCALE FACTOR FOR AMPLITUDE NORMALIZATION

;        FOURIER SERIES SPECTRUM PARAMETERS

WAVEAD:  .WORD  WAVETB       ; ADDRESS OF WAVEFORM TABLE TO FILL
PKAMP:   .BYTE  $3F          ; DESIRED PEAK AMPLITUDE OF WAVEFORM
NHARM:   .BYTE  16           ; HIGHEST HARMONIC TO GENERATE (16 IS MAX)
                             ; EXAMPLE SPECTRUM OF A SAWTOOTH WAVE
                             ; ALTER AFTER LOADING FOR OTHER WAVEFORMS
FSRAM:   .BYTE  0,0          ; DC COMPONENT
         .BYTE  255,$40      ; FUNDAMENTAL
         .BYTE  255/2,$40    ; 2ND HARMONIC
         .BYTE  255/3,$40    ; 3RD HARMONIC
         .BYTE  255/4,$40    ; 4TH HARMONIC
         .BYTE  255/5,$40    ; 5TH HARMONIC
         .BYTE  255/6,$40    ; 6TH HARMONIC
         .BYTE  255/7,$40    ; 7TH HARMONIC
         .BYTE  255/8,$40    ; 8TH HARMONIC
         .BYTE  255/9,$40    ; 9TH HARMONIC
         .BYTE  255/10,$40   ; 10TH HARMONIC
         .BYTE  255/11,$40   ; 11TH HARMONIC
         .BYTE  255/12,$40   ; 12TH HARMONIC
         .BYTE  255/13,$40   ; 13TH HARMONIC
         .BYTE  255/14,$40   ; 14TH HARMONIC
         .BYTE  255/15,$40   ; 15TH HARMONIC
         .BYTE  255/16,$40   ; 16TH HARMONIC

;        THIS PROGRAM FIRST HAS A FULL CYCLE OF THE WAVEFORM COMPUTED IN
;        ORDER TO DETERMINE THE POSITIVE AND NEGATIVE PEAK VALUES.
;        THEN IT COMPUTES THE WAVEFORM AGAIN SAMPLE-BY-SAMPLE AND
;        NORMALIZES THE AMPLITUDE TO BE BETWEEN 0 AND "PKAMP".
;        EACH NORMALIZED SAMPLE IS THEN PLACED INTO A TABLE STARTING AT
;        THE ADDRESS IN WAVEAD.  FINALLY, THE TABLE'S CONTENTS ARE
;        SCANNED AND SENT TO THE DIGITAL-TO-ANALOG CONVERTER FOR
;        MONITORING.

;        SCALE FACTOR DETERMINATION ROUTINE
;        THIS ROUTINE GOES THROUGH ONE CYCLE OF THE WAVEFORM DEFINED
;        BY THE SPECTRUM AT FSRAM AND FINDS THE MOST POSITIVE POINT AND
;        PUTS IT IN MAX AND FINDS THE MOST NEGATIVE POINT AND PUTS IT IN
;        MIN.   MAX AND MIN ARE DOUBLE PRECISION SIGNED NUMBERS

SCALE:   LDA    #0           ; ZERO THE POINT NUMBER
         STA    PNTNO
         STA    MIN+1
         STA    MAX+1
         LDA    #$C0         ; SET MAX TO C000 (TO AVOID OVERFLOW WHEN
         STA    MAX          ; COMPARING)
         LDA    #$40         ; SET MIN TO 4000 (TO AVOID OVERFLOW WHEN
         STA    MIN          ; COMPARING)
SCALE1:  JSR    FSEVAL       ; EVALUATE A WAVEFORM POINT
         LDX    HRMACC       ; GET WAVEFORM POINT INTO X AND Y
         LDY    HRMACC+1
         CPX    MAX          ; COMPARE WITH MAX
         BMI    SCALE3       ; JUMP IF DEFINITELY LESS THAN MAX
         BNE    SCALE2       ; JUMP IF DEFINITELY GREATER THAN MAX
         CPY    MAX+1        ; COMPARE LOW BYTES IF HIGH BYTES EQUAL
         BCC    SCALE3       ; JUMP IF LESS THAN MAX
SCALE2:  STX    MAX          ; UPDATE MAX IF EQUAL OR GREATER
         STY    MAX+1
SCALE3:  CPX    MIN          ; COMPARE WITH MIN
         BMI    SCALE4       ; JUMP IF DEFINITELY LESS THAN MIN
         BNE    SCALE5       ; JUMP IF DEFINITELY GREATER THAN MIN
         CPY    MIN+1        ; COMPARE LOW BYTES IF HIGH BYTES EQUAL
         BCS    SCALE5       ; JUMP IF GREATER THAN MIN
SCALE4:  STX    MIN          ; UPDATE MIN IF EQUAL OR LESS
         STY    MIN+1
SCALE5:  INC    PNTNO        ; INCREMENT POINT NUMBER
         BNE    SCALE1       ; GO FOR NEXT POINT IF NOT DONE

;        DETERMINE THE SCALE FACTOR,   SCALEF=PKAMP/(MAX-MIN)

         LDA    MAX+1        ; COMPUTE MAX-MIN AND PUT INTO DIVISOR
         SEC
         SBC    MIN+1
         STA    DVSR+1
         LDA    MAX
         SBC    MIN
         STA    DVSR
         LDA    PKAMP        ; PUT PKAMP INTO DIVIDEND, NEXT TO MOST
         STA    DVND+1       ; SIGNIFICANT BYTE
         LDA    #0           ; ZERO THE OTHER DIVIDEND BYTES
         STA    DVND
         STA    DVND+2
         STA    DVND+3
         JSR    SGNDIV       ; DO THE DIVISON
         LDA    DVND+2       ; MOVE THE QUOTIENT TO THE SCALE FACTOR
         STA    SCALEF
         LDA    DVND+3
         STA    SCALEF+1

;        GENERATE THE WAVEFORM POINTS, SCALE THEM, AND PUT THEM IN THE
;        WAVEFORM TABLE

WAVE:    LDA    #0           ; ZERO THE POINT NUMBER
         STA    PNTNO
         TAY                 ; ZERO THE WAVEFORM TABLE INDEX
WAVE1:   JSR    FSEVAL       ; EVALUATE A WAVEFORM POINT
         LDA    HRMACC+1     ; SUBTRACT MIN FROM THE POINT AND PLACE IT
         SEC                 ; IN THE MULTIPLIER
         SBC    MIN+1
         STA    PROD+3
         LDA    SCALEF       ; MULTIPLY BY THE SCALE FACTOR COMPUTED
         STA    MPCD         ; EARLIER
         LDA    SCALEF+1
         STA    MPCD+1
         LDA    HRMACC
         SBC    MIN
         STA    PROD+2
         JSR    SGNMPY
         LDA    PROD+1       ; GET SCALED, POSITIVE RESULT
         STA    (WAVEAD),Y   ; PUT IT INTO THE WAVEFORM TABLE
         INC    PNTNO        ; INCREMENT POINT NUMBER
         INY                 ; INCREMENT WAVE TABLE POINTER
         BNE    WAVE1        ; GO FOR ANOTHER POINT IF NOT FINISHED

;        WAVEFORM PLAYOUT FOR MONITORING
;        THIS ROUTINE CONTINUOUSLY SCANS THE WAVEFORM TABLE JUST
;        COMPUTED AND OUTPUTS THE WAVEFORM AT A SAMPLE RATE OF 8770 HZ,
;        THE SAME AS THE MUSIC PROGRAMS.  FUNDAMENTAL FREQUENCY IS 34 HZ
;        IT ALSO PULSES PORT B BIT 7 AT THE START OF EVERY CYCLE TO
;        SYNCHRONIZE A STANDARD OSCILLOSCOPE FOR WAVEFORM DISPLAY.
;        NOTE THAT PORT B BIT 7 IS PIN 15 ON THE APPLICATION CONNECTOR
;        AND THAT IT REQUIRES A 4.7K OHM PULLUP RESISTOR TO +5 TO WORK.

MONTOR:  LDA    PTBDIR       ; SET PORT B BIT 7 UP AS AN OUTPUT
         ORA    #$80
         STA    PTBDIR
         LDA    #$FF         ; SET UP THE DAC PORT AS AN OUTPUT
         STA    DACDIR
MONT1:   LDA    PTB          ; PULSE PORT B BIT 7
         ORA    #$80
         STA    PTB
         AND    #$7F
         STA    PTB
         LDY    #0           ; INITIALIZE WAVEFORM TABLE POINTER
MONT2:   LDA    (WAVEAD),Y   ; GET A SAMPLE FROM THE WAVEFORM TABLE
         STA    DAC          ; SEND IT TO THE DAC
         INY                 ; BUMP POINTER TO NEXT SAMPLE
         BEQ    MONT4        ; JUMP IF FINISHED WITH CYCLE
         LDX    #19          ; WASTE SOME TIME TO GET LOOP TIME OF 114
MONT3:   DEX                 ; STATES
         BNE    MONT3
         BEQ    MONT2        ; GO FOR NEXT SAMPLE
MONT4:   LDX    #15          ; WASTE LESS TIME TO ACCOUNT FOR OVERHEAD
MONT5:   DEX                 ; IN GENERATING THE SYNC PULSE
         BNE    MONT5
         BEQ    MONT1        ; GO START ANOTHER WAVEFORM CYCLE

;        THIS SUBROUTINE EVALUATES A POINT ON THE WAVEFORM SPECIFIED BY
;        THE SPECTRUM AT FSRAM.
;        NHARM SPECIFIES THE HIGHEST HARMONIC TO BE INCLUDED
;        PNTNO IS THE POINT NUMBER TO BE EVALUATED
;        THE COMPUTED POINT IS RETURNED IN IN HRMACC AS A 16 BIT TWOS
;        COMPLEMENT NUMBER
;        DESTROYS A, SAVES INDEX REGISTERS, USES ARITHMETIC SUBROUTINES

         .segment "PAGE1"    ; START FOURIER SERIES ROUTINES AT 100

FSEVAL:  TXA                 ; SAVE INDEX X
         PHA
         LDA    #0           ; CLEAR HARMONIC ACCUMULATOR
         STA    HRMACC
         STA    HRMACC+1
         STA    HRMCNT       ; ZERO HARMONIC COUNTER
         STA    NDXACC       ; ZERO THE INDEXING ACCUMULATOR
FSEV1:   LDA    HRMCNT       ; GET CURRENT HARMONIC NUMBER AND DOUBLE IT
         ASL    A
         TAX                 ; USE AS AN INDEX TO THE SPECTRUM TABLE
         LDA    FSRAM,X      ; GET AMPLITUDE
         STA    PROD+3       ; SAVE AS MULTIPLIER
         LDA    FSRAM+1,X    ; GET PHASE
         ADC    NDXACC       ; ADD IT TO THE INDEXING ACCUMULATOR
         JSR    COSINE       ; GET COSINE
         STA    MPCD         ; SAVE AS MULTIPLICAND
         LDA    #0           ; ZERO UNUSED BYTES IN MULTIPLIER AND
         STA    PROD+2       ; MULTIPLICAND
         STA    MPCD+1
         JSR    SGNMPY       ; MULTIPLY AMPLITUDE BY COSINE
         LDX    #5           ; SHIFT PRODUCT RIGHT 5 FOR 11 BIT RESULT
FSEV2:   JSR    SRQA         ; RIGHT JUSTIFIED IN PROD+1 AND PROD+2
         DEX
         BNE    FSEV2
         CLD                 ; ADD RESULT TO HARMONIC ACCUMULATOR
         LDA    HRMACC+1
         ADC    PROD+2
         STA    HRMACC+1
         LDA    HRMACC
         ADC    PROD+1
         STA    HRMACC
         LDA    HRMCNT       ; TEST IF CURRENT HARMONIC IS LAST ONE TO
         CMP    NHARM        ; INCLUDE
         BEQ    FSEV3        ; GO RETURN IF SO
         INC    HRMCNT       ; INCREMENT TO NEXT HARMONIC
         LDA    PNTNO        ; ADD POINT NUMBER TO THE INDEXING
         CLC                 ; ACCUMULATOR
         ADC    NDXACC
         STA    NDXACC
         JMP    FSEV1        ; LOOP FOR ANOTHER HARMONIC
FSEV3:   PLA                 ; RESTORE INDEX X
         TAX
         RTS                 ; RETURN

;        ENTER WITH ARGUMENT IN A, 0=0 DEGREES, 64=90 DEGREES, ETC.
;        EXIT WITH SIGNED COSINE IN A
;        DESTROYS INDEX X

COSINE:  CMP    #$40
         BCC    QUAD1        ; BRANCH IF IN QUADRANT 1
         CMP    #$80
         BCC    QUAD2        ; BRANCH IF IN QUADRANT 2
         CMP    #$C0
         BCC    QUAD3        ; BRANCH IF IN QUADRANT 3
QUAD4:   JSR    ANGNEG       ; IN QUADRANT 4, NEGATE THE ANGLE
QUAD1:   TAX                 ; IN QUADRANT 1, LEAVE ANGLE ALONE
         LDA    COSTAB,X     ; GET COSINE IN QUADRANTS 1 AND 4
         RTS                 ; RETURN
QUAD2:   JSR    ANGNEG       ; IN QUADRANT 2 NEGATE THE ANGLE
COS1:    TAX
         LDA    #0
         SEC
         SBC    COSTAB,X     ; GET -COSINE IN QUADRANTS 2 AND 3
         RTS                 ; RETURN
QUAD3:   AND    #$3F         ; IN QUADRANT 3 MASK THE ANGLE TO CONVERT
         BCC    COS1         ; TO QUADRANT 1 ANGLE


ANGNEG:  AND    #$3F         ; ISOLATE THE LOWER 6 BITS OF THE ANGLE
         EOR    #$3F         ; FLIP THEM
         CLC                 ; ADD 1 FOR TWOS COMPLEMENT
         ADC    #1
         RTS                 ; RETURN


;        65 POINT COSINE TABLE, QUADRANT 1

COSTAB:  .BYTE  $7F,$7F,$7F,$7F,$7F,$7F,$7E,$7E
         .BYTE  $7D,$7D,$7C,$7B,$7A,$79,$78,$77
         .BYTE  $76,$75,$73,$72,$71,$6F,$6D,$6C
         .BYTE  $6A,$68,$66,$65,$63,$61,$5E,$5C
         .BYTE  $5A,$58,$56,$53,$51,$4E,$4C,$49
         .BYTE  $47,$44,$41,$3F,$3C,$39,$36,$33
         .BYTE  $31,$2E,$2B,$28,$25,$22,$1F,$1C
         .BYTE  $19,$16,$12,$0F,$0C,$09,$06,$03
         .BYTE  $00

;        SIGNED MULTIPLY SUBROUTINE
;        ENTER WITH SIGNED MULTIPLIER IN PROD+2 AND PROD+3
;        ENTER WITH SIGNED MULTIPLICAND IN MPCD AND MPCD+1
;        RETURN WITH 16 BIT SIGNED PRODUCT IN PROD (HIGH) THROUGH
;        PROD+3 (LOW)
;        A DESTROYED, X AND Y PRESERVED

         .segment "PAGE2"    ; PUT MATH ROUTINES AT 200

SGNMPY:  LDA    PROD+2       ; GET MULTIPLIER
         STA    MPSAVE       ; AND SAVE IT
         LDA    PROD+3
         STA    MPSAVE+1
         JSR    UNSMPY       ; DO AN UNSIGNED MULTIPLY
         LDA    MPCD         ; TEST SIGN OF MULTIPLICAND
         BPL    SGNMP1       ; JUMP IF POSITIVE
         LDA    PROD+1       ; SUBTRACT MULTIPLIER FROM HIGH PRODUCT IF
         SEC                 ; NEGATIVE
         SBC    MPSAVE+1
         STA    PROD+1
         LDA    PROD
         SBC    MPSAVE
         STA    PROD
SGNMP1:  LDA    MPSAVE       ; TEST SIGN OF MULTIPLIER
         BPL    SGNMP2       ; GO RETURN IF POSITIVE
         LDA    PROD+1       ; SUBTRACT MULTIPLICAND FROM HIGH PRODUCT
         SEC                 ; IF NEGATIVE
         SBC    MPCD+1
         STA    PROD+1
         LDA    PROD
         SBC    MPCD
         STA    PROD
SGNMP2:  RTS                 ; RETURN

;        16 X 16 UNSIGNED MULTIPLY SUBROUTINE
;        ENTER WITH UNSIGNED MULTIPLIER IN PROD+2 AND PROD+3
;        ENTER WITH UNSIGNED MULTIPLICAND IN MPCD AND MPCD+1
;        RETURN WITH 16 BIT UNSIGNED PRODUCT IN PROD (HIGH) THROUGH
;        PROD+3 (LOW)
;        A DESTROYED, X AND Y PRESERVED

UNSMPY:  TXA                 ; SAVE X INDEX
         PHA
         LDA    #0           ; CLEAR UPPER PRODUCT
         STA    PROD
         STA    PROD+1
         LDX    #17          ; SET 17 MULTIPLY CYCLE COUNT
         CLC                 ; INITIALLY CLEAR CARRY
UNSM1:   JSR    SRQL         ; SHIFT MULTIPLIER AND PRODUCT RIGHT 1
                             ; PUTTING A MULTIPLIER BIT IN CARRY
         DEX                 ; DECREMENT AND CHECK CYCLE COUNT
         BEQ    UNSM2        ; JUMP OUT IF DONE
         BCC    UNSM1        ; SKIP MULTIPLICAND ADD IF MULTIPLIER BIT
                             ; IS ZERO
         LDA    PROD+1       ; ADD MULTIPLICAND TO UPPER PRODUCT
         CLC
         ADC    MPCD+1
         STA    PROD+1
         LDA    PROD
         ADC    MPCD
         STA    PROD
         JMP    UNSM1        ; GO FOR NEXT CYCLE
UNSM2:   PLA                 ; RESTORE X
         TAX
         RTS                 ; RETURN

;        QUAD SHIFT RIGHT SUBROUTINE
;        ENTER AT SRQA FOR ALGEBRAIC SHIFT RIGHT
;        ENTER AT SRQL FOR LOGICAL SHIFT
;        ENTER WITH QUAD PRECISION VALUE TO SHIFT IN PROD THROUGH PROD+3
;        DESTROYS A, PRESERVES X AND Y, RETURNS BIT SHIFTED OUT IN CARRY

SRQA:    LDA    PROD         ; GET SIGN BIT OF PROD IN CARRY
         ASL    A
SRQL:    ROR    PROD         ; LOGICAL SHIFT RIGHT ENTRY
         ROR    PROD+1
         ROR    PROD+2
         ROR    PROD+3
         RTS                 ; RETURN


;        QUAD SHIFT LEFT SUBROUTINE
;        ENTER AT SLQL TO SHIFT IN A ZERO BIT
;        ENTER AT RLQL TO SHIFT IN THE CARRY
;        ENTER WITH QUAD PRECISION VALUE TO SHIFT IN PROD THROUGH PROD+3
;        DESTROYS A, PRESERVES X AND Y, RETURNS BIT SHIFTED OUT IN CARRY

SLQL:    CLC                 ; SHIFT IN ZERO BIT ENTRY; CLEAR CARRY
RLQL:    ROL    PROD+3       ; SHIFT IN CARRY ENTRY
         ROL    PROD+2
         ROL    PROD+1
         ROL    PROD
         RTS                 ; RETURN

;        DOUBLE PRECISION SIGNED DIVIDE SUBROUTINE
;        ENTER WITH SIGNED DIVIDEND IN DVND (HIGH) THROUGH DVND+3 (LOW)
;        ENTER WITH SIGNED DIVISOR IN DVSR AND DVSR+1
;        EXIT WITH SIGNED QUOTIENT IN DVND+2 AND DVND+3 AND SIGNED
;        REMAINDER TIMES 2 IN DVND AND DVND+1
;        DESTROYS A, PRESERVES INDEX REGISTERS
;        NO CHECK FOR OVERFLOW OR DIVIDE BY 0

SGNDIV:  TXA                 ; SAVE THE INDEX REGISTERS
         PHA
         TYA
         PHA
SDIV:    LDA    DVND         ; COMPUTE SIGN OF QUOTIENT
         EOR    DVSR
         STA    MPSAVE       ; SAVE IT
         LDA    DVSR         ; ABSOLUTE VALUE OF DIVISOR
         BPL    SDIV1        ; BRANCH IF POSITIVE
         LDX    #DVSR+1-DVND ; NEGATE IF NEGATIVE
         LDY    #2
         JSR    MPNEG
SDIV1:   LDA    DVND         ; ABSOLUTE VALUE OF DIVIDEND
         BPL    SDIV2        ; JUMP IF POSITIVE
         LDX    #DVND+3-DVND ; NEGATE IF NEGATIVE
         LDY    #4
         JSR    MPNEG
SDIV2:   JSR    UNSDIV       ; DO AN UNSIGNED DIVIDE
         LDA    MPSAVE       ; GET SIGN OF QUOTIENT
         BPL    SDIV3        ; GO RETURN IF POSITIVE
         LDX    #DVND+3-DVND ; NEGATE IF NEGATIVE
         LDY    #2
         JSR    MPNEG
SDIV3:   PLA                 ; RESTORE INDEX REGISTERS
         TAY
         PLA
         TAX
         RTS                 ; RETURN


MPNEG:   SEC                 ; INITIALLY SET CARRY
MPNEG1:  LDA    #0           ; SUBTRACT A BYTE FROM 0 TO NEGATE IT
         SBC    DVND,X
         STA    DVND,X
         DEX                 ; BUMP TO NEXT MORE SIGNIFICANT BYTE
         DEY                 ; CHECK BYTE COUNT
         BNE    MPNEG1       ; LOOP IF NOT DONE
         RTS                 ; RETURN IF DONE

;        DOUBLE PRECISION UNSIGNED DIVIDE SUBROUTINE
;        ENTER WITH UNSIGNED DIVIDEND IN PROD (HIGH) THROUGH PROD+3 (LOW
;        ENTER WITH UNSIGNED DIVISOR IN MPCD AND MPCD+1
;        EXIT WITH UNSIGNED QUOTIENT IN PROD+2 AND PROD+3 AND UNSIGNED
;        REMAINDER TIMES 2 IN PROD AND PROD+1 AND CARRY FLAG
;        DESTROYS A, PRESERVES INDEX REGISTERS
;        NO CHECK FOR OVERFLOW OR DIVIDE BY 0

UNSDIV:  TXA                 ; SAVE X
         PHA
         TYA                 ; SAVE Y
         PHA
         LDX    #17          ; SET DIVIDE CYCLE COUNT
         CLC                 ; INITIALLY CLEAR CARRY
UNSDV1:  LDA    PROD+1       ; SUBTRACT DIVISOR FROM HIGH DIVIDEND
         SEC
         SBC    MPCD+1
         TAY
         LDA    PROD
         SBC    MPCD
         BCC    UNSDV2       ; SKIP IF OVERDRAW
         STA    PROD         ; UPDATE HIGH DIVIDEND IF NOT
         TYA
         STA    PROD+1
UNSDV2:  JSR    RLQL         ; SHIFT DIVIDEND LEFT 1 BRINGING IN
                             ; QUOTIENT BIT
         DEX                 ; DECREMENT CYCLE COUNT
         BNE    UNSDV1       ; LOOP IF NOT DONE
         PLA                 ; RESTORE Y
         TAY
         PLA                 ; RESTORE X
         TAX
         RTS                 ; RETURN

         .END
