;        COPYRIGHT 1977 BY MICRO TECHNOLOGY UNLIMITED, BOX 4596,
;        MANCHESTER, NEW HAMPSHIRE 03108
;        PROGRAM WRITTEN BY HAL CHAMBERLIN

;        THIS PROGRAM COMPILES A SIMPLIFIED SUBSET OF THE NOTRAN MUSIC
;        LANGUAGE INTO AN OBJECT CODE STRING FOR PLAYING BY THE KIM
;        NOTRAN INTERPRETER.

;        LINES OF NOTRAN SOURCE CODE ARE PROCESSED BY THE COMPILER AND
;        CONVERTED INTO A SERIES OF OBJECT CODE BYTES WHICH ARE STORED
;        IN MEMORY AND LINES OF OBJECT CODE LISTING WHICH ARE PRINTED BY
;        AN OUTPUT DEVICE.  IF A CONTROLLABLE INPUT DEVICE IS AVAILABLE
;        (ONE THAT CAN BE STARTED AND STOPPED UNDER PROGRAM CONTROL)
;        THEN ONLY ONE LINE OF SOURCE CODE NEEDS TO BE IN MEMORY AT
;        ONCE.  STORAGE SPACE IS ALSO REQUIRED FOR A SMALL SYMBOL TABLE
;        WHICH NEEDS 3 BYTES PER SYMBOL.  SEE THE PROGRAM LISTING FOR
;        ADDRESS VECTORS AND SIZES OF THE SYMBOL TABLE, OBJECT CODE
;        AREA, LINE INPUT BUFFER, AND LINE OUTPUT BUFFER.

;        NOTRAN SOURCE IS MADE UP OF LINES.  A LINE MAY HAVE AN OPTIONAL
;        IDENTIFIER AND MAY CONSIST OF ONE OR MORE SPECIFICATIONS.  THE
;        IDENTIFIER, IF PRESENT, MUST BE IN THE FIRST CHARACTER POSITION
;        OF THE LINE.  AN IDENTIFIER IS A UNIQUE NUMBER BETWEEN 1 AND
;        255.  IF THERE IS NO IDENTIFIER, THE FIRST CHARACTER POSITION
;        MUST BE BLANK.  IF THE FIRST CHARACTER OF A LINE IS AN *, THEN
;        THE ENTIRE LINE IS TREATED AS A COMMENT.

;        A SPECIFICATION MAY EITHER BE A KEYWORD SPECIFICATION OR A NOTE
;        SPECIFICATION.  A KEYWORD SPECIFICATION MAY BE EITHER
;        EXECUTABLE IF OBJECT CODE BYTES ARE GENERATED FOR IT OR
;        NON-EXECUTABLE IF IT ONLY INFLUENCES FUTURE COMPILER ACTIONS.  A
;        KEYWORD SPECIFICATION CONSISTS OF A THREE LETTER KEYWORD
;        FOLLOWED BY OPTIONAL PARAMETERS SEPARATED BY COMMAS.  A NOTE
;        SPECIFICATION CONSISTS OF A STRING OF CHARACTERS TO BE DEFINED
;        LATER.  MULTIPLE SPECIFICATIONS ON ONE LINE MUST BE SEPARATED
;        BY SEMICOLONS.  ANY NUMBER OF BLANKS (INCLUDING ZERO) MAY BE
;        INSERTED BEFORE AND AFTER SEMICOLONS, BETWEEN A KEYWORD AND ITS
;        PARAMETERS, AND BEFORE THE FIRST SPECIFICATION ON A LINE,
;        BLANKS MAY NOT APPEAR IN THE MIDDLE OF A NOTE SPECIFICATION.
;        MAXIMUM INPUT LINE LENGTH IS 72 CHARACTERS.

;        DUE TO THE ONE-PASS SIMPLIFIED NATURE OF THE COMPILER, FORWARD
;        REFERENCING IN JUMP AND JUMP TO SUBROUTINE STATEMENTS IS NOT
;        SUPPORTED.  A BLOCK OF STATEMENTS MAY HOWEVER BE DEFINED AND A
;        JUMP CREATED TO SKIP FORWARD OVER IT.  THE BEGINNING OF THE
;        BLOCK IS DEFINED BY A "SUB" STATEMENT AND THE END IS DEFINED BY
;        AN "ESB" STATEMENT.  A JUMP IS CREATED AT THE "SUB" STATEMENT
;        WHICH IS DIRECTED TO THE STATEMENT FOLLOWING THE "ESB".  THIS
;        IN EFFECT DEFINES A FORWARD REFERENCE JUMP THAT MAY BE USED TO
;        JUMP OVER SUBROUTINE DEFINITIONS.  ONLY ONE "SUB-ESB" PAIR MAY
;        BE ACTIVE AT A TIME.

;        THE KEYWORD SPECIFICATIONS RECOGNIZED ARE AS FOLLOWS (X IS A
;        NUMERICAL PARAMETER):
;               NVC X        DEFINE NUMBER OF VOICES TO MIX, X IS IN
;                            RANGE IF 1-4 (SEE INTERPRETER LISTING)
;                            (EXECUTABLE)
;               ACT X,X,..,X ACTIVATE VOICE(S) X, X IN RANGE OF 1-4,
;                            (EXECUTABLE)
;               DCT X,X,..,X DEACTIVATE VOICE(S) X (EXECUTABLE)
;               WAV X,Y      ASSIGN WAVEFORM X TO VOICE Y. X IN RANGE OF
;                            1-16, Y IN RANGE OF 1-4
;                            (NOTE: CORRESPONDANCE BETWEEN WAVEFORM
;                            NUMBERS AND ACTUAL WAVEFORMS DEFINED WHEN
;                            THE INTERPRETER IS RUN)
;                            (NON-EXECUTABLE) .
;               TPO X        SET TEMPO TO X, X IN RANGE OF 1-255
;                            QUARTER NOTE DURATION (MILLISECONDS) =
;                            X*5.472 (EXECUTABLE)
;               ABS          FORCES ABSOLUTE PITCH IN OBJECT CODE OF THE
;                            NEXT NOTE SOUNDED BY EACH VOICE
;                            (NON-EXECUTABLE)
;               JMP X        UNCONDITIONAL JUMP TO THE LINE WHOSE
;                            IDENTIFIER MATCHES X WHILE PLAYING.
;                            (EXECUTABLE)
;               JSR X        JUMP TO MUSICAL SUBROUTINE TO THE LINE
;                            WHOSE IDENTIFIER MATCHES X WHILE PLAYING.
;                            (EXECUTABLE)
;               RTS          RETURN FROM MUSICAL SUBROUTINE (EXECUTABLE)
;               SUB          DEFINE BEGINNING OF SKIPPED STATEMENT BLOCK
;                            (EXECUTABLE)
;               ESB          DEFINE END OF SKIPPED STATEMENT BLOCK
;                            (EXECUTABLE)
;               END          END OF NOTRAN SOURCE (EXECUTABLE)


;        NOTE SPECIFICATIONS HAVE THE FOLLOWING FORMAT:

;        (OPTIONAL VOICE DIGIT)(NOTE LETTER) (OPTIONAL # OR @) (OPTIONAL
;        OCTAVE NUMBER) (DURATION LETTER) (OPTIONAL DURATION MODIFIER)

;        THE INDIVIDUAL FIELDS ARE AS FOLLOWS:

;        OPTIONAL VOICE DIGIT A DIGIT IN THE RANGE OF 1 TO 4. DOES NOT
;                              REALLY DO ANYTHING BUT WHEN PRESENT IS
;                              COMPARED WITH THE VOICE NUMBER THAT THE
;                              INTERPRETER WOULD ACTUALLY ASSIGN TO THIS
;                              NOTE AND AN ERROR IS SIGNALLED IF THERE
;                              IS A MISMATCH.
;        NOTE LETTER           A, B, C, D, E, F, G ARE LEGAL
;        OPTIONAL # OR @       # FOR A HALF-STEP INCREMENT IN PITCH
;                              @ FOR A HALF-STEP DECREMENT IN PITCH
;        OPTIONAL OCTAVE NUMBER IF PRESENT SPECIFIES THE OCTAVE, RANGE
;                              IS 1-6, C4 IS MIDDLE C, C6 IS HIGHEST
;                              ALLOWABLE NOTE, AN OCTAVE SPANS FROM C TO
;                              B.  IF NOT PRESENT, THE OCTAVE LAST
;                              PLAYED BY THE VOICE IS USED.
;        DURATION LETTER       W = WHOLE, H = HALF, Q = QUARTER,
;                              E = EIGHTH, S = SIXTEENTH, T = THIRTY-
;                              SECOND
;        OPTIONAL DURATION MODIFIER  . SPECIFIES 3/2 OF THE SPECIFIED
;                              DURATION, 3 SPECIFIES 2/3 OF THE
;                              SPECIFIED DURATION.  W.  W3  T3 NOT
;                              AVAILABLE.

;                      RULES FOR ASSIGNING NOTES TO VOICES

;        FOR PURPOSES OF THE KIM MUSIC SYSTEM, MUSIC IS BROKEN UP INTO A
;        SERIES OF EVENTS.  AN EVENT IS DEFINED AS THE INTERVAL BETWEEN
;        *ANY* CHANGE IN THE NOTES OF A CHORD BEING PLAYED.  THE
;        ORIGINAL FORM OF THE MUSIC SYSTEM REQUIRED 5 BYTES FOR EVERY
;        EVENT EVEN IF ONLY ONE NOTE OF A 4 NOTE CHORD CHANGED BETWEEN
;        TWO SUCCESSIVE EVENTS.  LETS ASSUME FOR THE MONENT THE
;        EXISTENCE OF A LONG STRING OF EVENTS WITH NO CONTROL
;        SPECIFICATIONS (TEMPO CHANGE, ETC.) INTERSPERSED.  AT THE
;        CONCLUSION OF THE PREVIOUS EVENT THE INTERPRETER WILL FETCH
;        NOTE CODE BYTES FROM THE CODE STRING ONE-AT-A-TIME TO BUILD UP
;        4 NOTES FOR THE NEXT EVENT.  HOWEVER IF, AS IS OFTEN THE CASE
;        IN MUSIC, THE NOTES OF THE PREVIOUS EVENT WERE OF DIFFERENT
;        DURATIONS, ONLY THE CHANGED NOTES NEED TO BE FETCHED FROM THE
;        CODE STRING.  THE "UNEXPIRED" NOTES FROM THE PREVIOUS EVENT CAN
;        BE CARRIED OVER TO THE CURRENT EVENT.  THE RULE FOR ASSIGNING
;        VOICE NUMBERS (1, 2, 3, OR 4 WHICH HAVE BEEN EQUATED WITH
;        DIFFERENT WAVEFORMS) IS THAT THEY ARE ASSIGNED TO CODE BYTES
;        SEQUENTIALLY STARTING WITH VOICE 1.  HOWEVER, IF VOICE 1 IS
;        BEING CARRIED OVER FROM THE PREVIOUS EVENT THEN IT IS SKIPPED
;        AND VOICE 2 IS TRIED.  THIS PROCESS, WHICH IS CALLED "EVENT
;        BUILDING" CONTINUES UNTIL ALL "EXPIRED" VOICES ARE ASSIGNED NEW
;        NOTES FROM THE CODE STRING.  IF A VOICE IS TO BE SILENT FOR THE
;        EVENT, A REST SPECIFICATION IS PLACED IN THE CODE STRING.  IF A
;        VOICE IS TO BE SILENT FOR AN EXTENDED PERIOD OF TIME, IT MAY BE
;        "DEACTIVATED".  INACTIVE VOICES ARE SKIPPED WHEN NOTES ARE
;        ASSIGNED TO VOICES.

;        AFTER THE NOTES ARE ASSIGNED, THE EVENT LENGTH IS COMPUTED.
;        THE EVENT LENGTH IS SIMPLY THE DURATION OF THE VOICE WITH THE
;        SHORTEST REMAINING DURATION.  THE INTERPRETER THEN PLAYS THE
;        CHORD THAT WAS SET UP FOR THIS SHORTEST DURATION AND THEN LOOPS
;        BACK TO SET UP FOR THE NEXT EVENT.

;        CONTROL SPECIFICATIONS SUCH AS A TEMPO CHANGE SHOULD ONLY OCCUR
;        BETWEEN THE GROUPS OF NOTE CODES THAT COMPRISE AN EVENT.  IF
;        THE INTERPRETER SEES SUCH A CONTROL COMMAND WHILE BUILDING AN
;        EVENT, IT ABORTS THE PARTIALLY BUILT EVENT, PROCESSES THE
;        CONTROL COMMAND, AND THEN STARTS ANEW BUILDING AN EVENT.  THE
;        COMPILER ALERTS THE USER THROUGH AN ERROR MESSAGE IF AN ATTEMPT
;        HAS BEEN MADE TO INSERT A CONTROL COMMAND IN THE MIDDLE OF AN
;        EVENT GROUP.  THE SAME IS TRUE IF AN IDENTIFIER IS PLACED ON A
;        NOTE SPECIFICATION THAT IS IN THE MIDDLE OF AN EVENT GROUP.

;        IN ORDER TO CONSERVE SPACE IN THE OBJECT CODE FORMAT AN
;        EXPLICIT VOICE NUMBER SPECIFICATION IS NOT INCLUDED IN THE NOTE
;        CODES.  THE ASSIGNMENT OF VOICES TO NOTE CODES IS PERFORMED BY
;        THE NOTRAN OBJECT CODE INTERPRETER.  IN ORDER TO MINIMIZE
;        CODING ERRORS BY THE NOTRAN USER, THE COMPILER DUPLICATES THE
;        ASSIGNMENT ACTIONS OF THE INTERPRETER AND SIGNALS ANY MISMATCH
;        BETWEEN THE VOICE THAT WOULD BE ASSIGNED BY THE INTERPRETER AND
;        THE VOICE INTENDED BY THE USER.

;        ACTUALLY THIS COMPILER IS MORE LIKE AN ASSEMBLER IN THAT NOTE
;        AND CONTROL SPECIFICATIONS ARE TRANSLATED AND PASSED
;        ONE-FOR-ONE INTO OBJECT CODE FOR THE NOTRAN INTERPRETER.
;        CERTAINLY A MORE SOPHISTICATED COMPILER IS POSSIBLE WHICH, FOR
;        EXAMPLE, MIGHT ALLOW THE USER TO SPECIFY THE MUSIC
;        "HORIZONTALLY" ONE VOICE LINE AT A TIME RATHER THAN
;        "VERTICALLY" ONE CHORD AT A TIME.

;        ERROR MESSAGES ARE AS FOLLOWS:

;        ER-01 ARGUMENT OUT OF RANGE, EITHER TOO BIG OR TOO SMALL
;        ER-02 UNDEFINED IDENTIFIER IN A JMP OR JSR SPECIFICATION
;        ER-03 IDENTIFIER HAS ALREADY BEEN USED, IT IS IGNORED
;        ER-04 SYMBOL TABLE OVERFLOW, THE IDENTIFIER IS IGNORED
;        ER-05 OBJECT CODE OVERFLOW, THE OBJECT CODE BYTE IS NOT STORED
;        ER-06 INCOMPREHENSIBLE SPECIFICATION, SKIP TO NEXT
;              SPECIFICATION OR STATEMENT
;        ER-07 SPECIFIED VOICE NUMBER AND ASSUMED VOICE NUMBER DO NOT
;              AGREE, ASSUMED VOICE NUMBER IS USED
;        ER-08 NOTE PITCH OUT OF RANGE, EITHER TOO HIGH OR TOO LOW OR
;              OCTAVE NUMBER OMITTED AND VOICE HAS NOT BEEN PREVIOUSLY
;              SOUNDED, USE HIGHEST AVAILABLE PITCH
;        ER-09 ILLEGAL DURATION, NOTE IS SKIPPED
;        ER-10 EXECUTABLE CONTROL SPECIFICATION IN MIDDLE OF EVENT
;              BUILD, PARTIAL EVENT IS SKIPPED AND CONTROL SPEC IS
;              EXECUTED.
;        ER-11 IDENTIFIER OCCURS IN THE MIDDLE OF AN EVENT, THE
;              IDENTIFIER IS PROCESSED.
;        ER-12 ATTEMPT MADE TO NEST SUB-ESB PAIR, SPECIFICATION IGNORED
;        ER-13 ESB WITHOUT A MATCHING SUB SPECIFICATION, THE ESB IS
;              IGNORED
;        ER-14 HANGING SUB AT END OF SONG
;        ER-15 NOTES ENCOUNTERED BUT NO VOICES ARE ACTIVE, COMPILATION
;              ABORTED


;        SINCE THE COMPILER IS NOT VERY SOPHISTICATED, OCCASIONALLY AN
;        ERROR MESSAGE MAY BE INAPPROPRIATE OR SEPARATED FROM THE ACTUAL
;        ERROR LOCATION.  BE ON THE LOOKOUT FOR ANYTHING WHEN THE ERROR
;        CODE IS 1, 6, 8, OR 9.

         .zeropage           ; KEEP ALL CONSTANTS AND DATA IN PAGE 0

KIMMON   =      $1C22        ; ENTRY POINT TO KIM MONITOR
KIMSAV   =      $1C00        ; SAVE STATUS ENTRY POINT TO KIM MONITOR
KIMICH   =      $1E5A        ; KIM TTY INPUT A CHARACTER INTO A, KEEPS X
KIMOCH   =      $1EA0        ; KIM TTY OUTPUT A CHAR FROM A, KEEPS X
KIMDLY   =      $1ED4        ; KIM TTY DELAY ONE BIT TIME, KEEPS X

;        NOTE: THESE ARE PARAMETERS THAT MUST BE SET UP BY THE USER
;        ACCORDING TO THE SYSTEM MEMORY CONFIGURATION
;        DEFAULT SETTINGS SHOWN FOR 4K EXPANSION STARTING AT 2000 (HEX)
;        AND USE OF DEFAULT 1/0 ROUTINES

INBFA:   .WORD  $300         ; INPUT BUFFER ADDRESS, 73 BYTES USED
OUBFA:   .WORD  $300+73      ; OUTPUT BUFFER ADDRESS, 74 BYTES USED
SYMTA:   .WORD  $300+73+74   ; SYMBOL TABLE ADDRESS
CODEA:   .WORD  CMPEND       ; OBJECT CODE AREA ADDRESS
CODELN:  .WORD  $2FFF-CMPEND ; MAXIMUM NUMBER OF MUSIC OBJECT CODE BYTES
                             ; ALLOWED
SYMTLN:  .BYTE  (100-1)/3    ; MAXIMUM NUMBER OF SYMBOLS ALLOWED, 3
                             ; BYTES OF MEMORY USED FOR EACH SYMBOL
                             ; PLUS 1 FOR AN END MARK

;        THESE ADDRESSES MAY BE ALTERED BY THE USER TO USE ALTERNATE I/O
;        ROUTINES IF A TELETYPE IS NOT AVAILABLE

INP:     .WORD  DFIN         ; INPUT ROUTINE ADDRESS
INPINT:  .WORD  DFINIT       ; INPUT ROUTINE INITIALIZE ADDRESS
OUT:     .WORD  DFOU         ; OUTPUT ROUTINE ADDRESS
OUTINT:  .WORD  DFOUIT       ; OUTPUT ROUTINE INITIALIZE ADDRESS
ERR:     .WORD  DFERR        ; ERROR NOTIFICATION ROUTINE, CALLED WHEN
                             ; AN ERROR IS ENCOUNTERED AND LISTING IS
                             ; SUPPRESSED

;        LISTING CONTROL PARAMETERS

LIST:    .BYTE  1            ; MUSIC OBJECT CODE LISTING IN HEX IF NOT 0
ECHO:    .BYTE  1            ; ECHO INPUT STATEMENT IN LISTING IF NOT 0

;         ADDITIONAL CONSTANTS AND VARIABLES USED BY THE COMPILER

INBFPT:  .BYTE  0            ; INPUT BUFFER POINTER, OFFSET FROM (INBFA}
OUBFPT:  .BYTE  0            ; OUTPUT BUFFER POINTER,OFFSET FROM (OUBFA)
CODEPT:  .WORD  0            ; OBJECT CODE POINTER, ABS ADDRESS
CODECT:  .WORD  0            ; COUNT OF OBJECT CODE BYTES GENERATED
SYMTPT:  .WORD  0            ; SYMBOL TABLE POINTER, ABS ADDRESS
SYMTCT:  .BYTE  0            ; COUNT OF SYMBOLS ENTERED INTO THE TABLE
INDJMP:  .WORD  0            ; TEMPORARY STORAGE FOR INDIRECT JUMP
NBF:     .BYTE  0            ; RESULT OF NUMBER COLLECT ROUTINE
ENDFLG:  .BYTE  0            ; SET NON-ZERO WHEN END STATEMENT PROC.
SUBSKP:  .WORD  0            ; ADDR OF "SUB" STATEMNENT IN OBJECT CODE

                             ; RETURN PARAMETERS FROM NOTE COLLECT
NTVOIC:  .BYTE  0            ; VOICE NUMBER, IF SPECIFIED, 0 OTHERWISE
NTDUR:   .BYTE  0            ; DURATION CODE FOR THE NOTE
NTDURX:  .BYTE  0            ; DURATION TIME FOR THE NOTE
NTPTC:   .BYTE  0            ; COMPOSITE PITCH FOR THE NOTE
NTOCT:   .BYTE  0            ; OCTAVE NUMBER FOR THE NOTE

NTERR:   .BYTE  0            ; ERROR FLAG FOR NOTE COLLECT ROUTINE
NMERR:   .BYTE  0            ; ERROR FLAG FOR NUMBER COLLECT ROUTINE

                             ; DATA FOR PROCESSING MUSICAL EVENTS
EVTBLD:  .BYTE  0            ; EVENT BEING BUILT IF NOT ZERO
DUR:     .BYTE  0            ; DURATION OF SHORTEST NOTE
VPPNT:   .BYTE  0            ; VOICE NUMBER BEING PROCESSED
VXPTC:   .RES   4            ; CURRENT VOICE COMPOSITE PITCHES
VXOCT:   .RES   4            ; CURRENT VOICE PITCH OCTAVES
VXABS:   .RES   4            ; FORCE ABSOLUTE PITCH FLAGS, NOT 0 = FORCE
VXWAV:   .RES   4            ; CURRENT VOICE WAVEFORM NUMBERS
VXDUR:   .RES   4            ; CURRENT VOICE DURATIONS

KWTP:    .BYTE  0            ; MISCELLANEOUS TEMPORARY STORAGE FOR LOW
KWMC:    .BYTE  0            ; LEVEL ROUTINES
CDSAV:   .BYTE  0

;        DFIN DEFAULT INPUT ROUTINE

;        THIS INPUT ROUTINE IS DESIGNED TO BE USED WITH A SERIAL DEVICE
;        SUCH AS A #33 TELETYPE WITH PAPER TAPE.  THE PAPER TAPE SHOULD
;        BE FORMATTED INTO LINES WITH THE CONTROL CHARACTER SEQUENCE [CR
;        LF DC1 DEL] BETWEEN THE TEXT OF EACH LINE.  THE [DC1 DEL]
;        SEQUENCE IS USED TO STOP THE TTY READER AFTER AN INPUT LINE HAS
;        BEEN READ.  TO INITIATE READING OF A LINE THIS ROUTINE FIRST
;        SENDS A DC2 CONTROL CHARACTER WHICH STARTS THE TTY READER.
;        TEXT READ IN IS STORED IN THE INPUT BUFFER.  ANY CONTROL
;        CHARACTERS PRECEEDING THE TEXT ARE THROWN AWAY SO THAT THE
;        FIRST CHARACTER IN THE BUFFER IS THE FIRST PRINTABLE CHARACTER
;        IN THE TEXT.  EXCESS CHARACTERS IN THE INPUT LINE BEYOND 72 ARE
;        THROWN AWAY UNTIL A "CR" IS ENCOUNTERED.  BS (0X08) OR < (0X5F)
;        APPEARING IN THE STRING CAUSES THE PREVIOUS CHARACTER IN THE
;        BUFFER TO BE DELETED THUS EFFECTING A BACKSPACE.  LOWER CASE
;        ALPHABETIC CHARACTERS ARE TRANSLATED TO THEIR UPPER CASE
;        EQUIVALENT.  WHEN THE DC1 CHARACTER IS READ AND ECHOED BACK
;        THROUGH THE KIM TTY PORT, THE TTY READER STOPS THUS ALLOWING
;        TIME TO COMPILE THE LINE AND PRINT THE LISTING IF ENABLED.  THE
;        TEXT STORED IN THE INPUT BUFFER IS TERMINATED WITH A "CR"
;        CHARACTER.  THE KIM TTY INPUT AND OUTPUT ROUTINES ARE UTILIZED
;        FOR INDIVIDUAL CHARACTER INPUT AND OUTPUT.  NOTE THAT TTY MODE
;        OF OPERATION (JUMPER FROM A-XX TO A-XX ON THE KIM BOARD) MUST
;        BE SELECTED FOR THE TTY INPUT ROUTINE TO FUNCTION PROPERLY.

;        THE USER MAY SUBSTITUTE HIS OWN INPUT ROUTINE.  THE COMPILER
;        ONLY REQUIRES THAT THE TEXT IN THE INPUT BUFFER START WITH THE
;        FIRST CHARACTER TO BE PROCESSED AND BE TERMINATED WITH A "CR".
;        THE USER ROUTINE MAY FREELY UTILIZE ALL OF THE REGISTERS, AND
;        ANY BASE PAGE LOCATIONS NOT APPEARING IN THE COMPILER LISTING.

         .segment "CODE"     ; PUT DEFAULT I/O ROUTINES IN PAGE 2

DFINIT:  RTS                 ; DUMMY INPUT INITIALIZE ROUTINE

DFIN:    LDX    #0           ; INITIALIZE INPUT BUFFER POINTER
         LDA    #$12         ; TRANSMIT AN XON (DC2) TO START TTY READER
         JSR    KIMOCH
DFIN1:   JSR    KIMICH       ; WAIT FOR AN INPUT CHARACTER
         CMP    #$20         ; TEST IF IT IS ANY KIND OF CONTROL CHAR
         BCC    DFIN1        ; IGNORE IT IF SO
         CMP    #$7F         ; IGNORE DEL ALSO
         BEQ    DFIN1
         BNE    DFIN3        ; GO STORE FIRST TEXT CHARACTER
DFIN2:   JSR    KIMICH       ; GET A TEXT CHARACTER
         CMP    #$7F         ; TEST IF DEL
         BEQ    DFIN2        ; IGNORE IF SO
         CMP    #$0D         ; TEST IF CR
         BEQ    DFIN4        ; JUMP IF SO
         CPX    #72          ; TEST IF 72 TEXT CHARS ALREADY BEEN STORED
         BEQ    DFIN2        ; IGNORE BEYOND 72 UNTIL CR
DFIN3:   CMP    #$08         ; TEST IF IT IS A BACKSPACE CONTROL
         BEQ    DFIN32       ; JUMP IF IT IS
         CMP    #'<'         ; TEST IF IT IS A BACKARROW
         BNE    DFIN35       ; SKIP AHEAD IF NOT
DFIN32:  CPX    #0           ; EXECUTE BACKSPACE, TEST IF AT START OF
         BEQ    DFIN35       ; BUFFER, NO BACKSPACE IF SO
         DEX
DFIN35:  CMP    #$7B         ; TEST IF LOWER CASE ALPHABETIC
         BCS    DFIN37       ; JUMP AHEAD IF NOT
         CMP    #$61
         BCC    DFIN37       ; JUMP AHEAD IF NOT
         SBC    #$20         ; TRANSLATE LOWER CASE TO UPPER CASE
DFIN37:  PHA                 ; STORE CHARACTER IN INPUT BUFFER
         TXA
         TAY
         PLA
         STA    (INBFA),Y
         INX                 ; INCREMENT BUFFER INDEX
         BNE    DFIN2        ; GO FOR NEXT CHARACTER

DFIN4:   PHA                 ; STORE THE CR IN THE BUFFER
         TXA
         TAY
         PLA
         STA    (INBFA),Y
         LDX    #44          ; WAIT 4 CHARACTER TIMES AT CURRENT BAUD
DFIN5:   JSR    KIMDLY       ; RATE TO AVOID POSSIBLE CONFLICT BETWEEN
         DEX                 ; INPUT TERMINATION SEQUENCE AND
         BNE    DFIN5        ; LISTING OUTPUT
         RTS                 ; RETURN WITH INPUT BUFFER LOADED


;        DFOU DEFAULT OUTPUT ROUTINE

;        THIS OUTPUT ROUTINE IS DESIGNED TO BE USED WITH A SERIAL DEVICE
;        SUCH AS A #33 TELETYPE.  THE COMPILER SUPPLIES AN OUTPUT BUFFER
;        CONTAINING A FORMATTED CHARACTER STRING TERMINATED BY ASCII
;        "CR" AND "LF" CONTROL CHARACTERS.  THE LINE HAS A MAXIMUM OF 72
;        PRINTABLE CHARACTERS.  THE KIM TTY OUTPUT ROUTINE IS USED FOR
;        INDIVIDUAL CHARACTER OUTPUT.

;        THE USER MAY SUBSTITUTE HIS OWN OUTPUT ROUTINE.  THE USER
;        ROUTINE MAY FREELY UTILIZE ALL OF THE REGISTERS, AND ANY BASE
;        PAGE LOCATIONS NOT APPEARING IN THE COMPILER LISTING.

DFOUIT:  RTS                 ; DUMMY OUTPUT INITIALIZE ROUTINE

DFOU:    LDX    #0           ; INITIALIZE OUTPUT POINTER
DFOUT1:  TXA                 ; GET A CHARACTER FROM THE BUFFER
         TAY
         LDA    (OUBFA),Y
         CMP    #$0A         ; TEST IF IT IS A LF
         BEQ    DFOUT2       ; JUMP OUT IF SO
         JSR    KIMOCH       ; OUTPUT THE CHARACTER
         INX                 ; INCREMENT OUTPUT POINTER
         BNE    DFOUT1       ; GO OUTPUT NEXT CHAR
DFOUT2:  JSR    KIMOCH       ; OUTPUT THE LF
         RTS                 ; AND RETURN


;        DFERR DEFAULT ERROR ROUTINE TO BE USED WHEN LISTING IS
;        SUPPRESSED ERROR CODE IS IN A.
;        A "SAVE STATUS" CALL IS MADE TO THE KIM MONITOR WHERE THE USER
;        CAN EXAMINE THE ERROR CODE AND EITHER CONTINUE OR ABORT THE
;        COMPILATION.

;        THE USER MAY SUPPLY HIS OWN ERROR ROUTINE. THE INDEX REGISTERS
;        X AND Y, SHOULD BE SAVED WHILE THE ERROR REPORT IS BEING MADE
;        AND RESTORED BEFORE RETURNING TO THE COMPILER.

DFERR:   JMP    KIMSAV       ; GO TO KIM SAVE STATUS ENTRY POINT
         RTS                 ; RETURN TO NOTRAN COMPILER

         .segment "CODE2"    ; START IN EXTENDED MEMORY

NOTRAN:  CLD                 ; INSURE BINARY ARITHMETIC
         LDX    #$F0         ; INITIALIZE STACK POINTER
         TXS
         LDA    #0           ; ZERO SOME PARAMETERS
         STA    SYMTCT       ; NUMBER OF SYMBOLS IN TABLE
         STA    CODECT       ; NUMBER OF OBJECT CODE BYTES GENERATED
         STA    CODECT+1
         STA    SUBSKP       ; CLEAR SKIP ADDRESS IN SUB STATEMENT
         STA    SUBSKP+1
         STA    EVTBLD       ; TURN EVENT BEING BUILT FLAG OFF
         STA    ENDFLG       ; TURN END FLAG OFF
         TAY                 ; CLEAR THE SYMBOL TABLE
         STA    (SYMTA),Y
         STA    VPPNT        ; INITIALIZE VOICE PROCESSING POINTER
         TAX
NOTR1:   LDA    #0
         STA    VXWAV,X      ; DEFAULT TO WAVEFORM 1 ON ALL VOICES
         LDA    #$FF
         STA    VXDUR,X      ; DEACTIVATE ALL VOICES
         STA    VXABS,X      ; FORCE ABSOLUTE PITCH ON ALL VOICES
         INX
         CPX    #4
         BNE    NOTR1
         LDA    CODEA        ; INITIALIZE OBJECT CODE POINTER
         STA    CODEPT
         LDA    CODEA+1
         STA    CODEPT+1
         JSR    INIT         ; INITIALIZE INPUT ROUTINE
         JSR    OUIT         ; INITIALIZE OUTPUT ROUTINE

STAT:    JSR    IN           ; READ AN INPUT LINE
         LDY    #0
         LDA    ECHO         ; TEST IF ECHO TO OUTPUT ENABLED
         BNE    STAT1        ; SKIP AHEAD IF SO
         LDA    (INBFA),Y    ; LOOK AT FIRST CHAR. OF INPUT LINE IF NOT
         CMP    #'*'         ; TEST IF IT IS A COMMENT LINE
         BNE    STAT3        ; JUMP AHEAD IF NOT A COMMENT
         LDA    LIST         ; IF A COMMENT, SEE IF CODE LISTING ENABLED
         BEQ    STAT         ; IGNORE COMMENT IF LISTING DISABLED
         LDY    #0           ; COPY INPUT BUFFER INTO OUTPUT BUFFER
STAT1:   LDA    (INBFA),Y    ; GET A CHARACTER FROM THE INPUT BUFFER
         STA    (OUBFA),Y    ; PUT IT INTO THE OUTPUT BUFFER
         INY                 ; INCREMENT X TO NEXT CHARACTER
         CMP    #$0D         ; TEST IF A CARRIAGE RETURN WAS MOVED
         BEQ    STAT2        ; JUMP OUT IF SO
         BNE    STAT1        ; GO MOVE ANOTHER CHARACTER
STAT2:   LDA    #$0A         ; PUT A LINE FEED AT END OF OUTPUT BUFFER
         STA    (OUBFA),Y
         JSR    OU           ; PRINT AN OUTPUT LINE

STAT3:   LDY    #0           ; INITIALIZE INPUT BUFFER POINTER
         STY    INBFPT
         STY    OUBFPT       ; INITIALIZE OUTPUT BUFFER POINTER
         JSR    OULOC        ; GENERATE CURRENT LOCATION ON LISTING
         LDA    (INBFA),Y    ; GET FIRST CHARACTER OF INPUT LINE
         CMP    #'*'         ; TEST IF COMMENT LINE
         BEQ    STAT         ; GO FOR NEXT STATEMENT IF A COMMENT LINE
         CMP    #' '         ; TEST IF A BLANK
         BEQ    STAT8        ; JUMP IF SO, NO IDENTIFIER FOR LINE
         CMP    #'0'         ; TEST IF A DIGIT
         BCC    STAT4        ; JUMP IF NOT
         CMP    #'9'+1
         BCC    STAT6        ; JUMP IF IT IS A DIGIT
STAT4:   LDA    #6           ; SIGNAL ER 6 IF NOT A *, DIGIT, OR BLANK
STAT5:   JSR    ER
         JMP    ESTAT        ; GO TO END OF STATEMENT PROCESSING

STAT6:   LDA    EVTBLD       ; TEST IF IDENTIFIER IN MIDDLE OF EVENT
         BEQ    STAT65
         LDA    #$11         ; GENERATE ER-11 IF SO
         JSR    ER           ; AND PROCESS IDENTIFIER ANYWAY
STAT65:  JSR    NCOL         ; EVALUATE THE STATEMENT IDENTIFIER
         LDA    NMERR        ; TEST FOR OVERFLOW
         BNE    STAT5        ; JUMP IF SO
         LDA    NBF          ; GET THE IDENTIFIER
         BEQ    STAT4        ; ZERO NOT ALLOWED FOR AN IDENTIFIER
         JSR    SYMSR        ; CHECK FOR DUPLICATE SYMBOL IN THE TABLE
         BCC    STAT7        ; JUMP IF NOT
         LDA    #3           ; SIGNAL ER 3 IF DUPLICATE IDENTIFIER
         JSR    ER
         JMP    STAT8        ; CONTINUE PROCESSING THE STATEMENT
STAT7:   JSR    SYMAD        ; ADD THE IDENTIFIER TO THE SYMBOL TABLE
         BCS    STAT8        ; JUMP IF SUCCESSFUL ADD
         LDA    #4           ; GENERATE ER-4 IF SYMBOL TABLE OVERFLOW
         JSR    ER

;        PROCESS REMAINDER OF STATEMENT AFTER LEADING BLANK, IDENTIFIER,
;        OR SEMICOLON

STAT8:   JSR    NNB          ; MOVE TO NEXT NON-BLANK CHARACTER
         JSR    KWCOL        ; TRY TO RECOGNIZE A KEYWORD
         BCC    STAT10       ; SKIP AHEAD IF NO KEYWORD
         LDA    KWTAB,X      ; MOVE JUMP ADDRESS FROM KEYWORD TABLE TO
         STA    INDJMP       ; INDIRECT JUMP POINTER IN PAGE 0
         LDA    KWTAB+1,X
         STA    INDJMP+1
         JMP    (INDJMP)     ; JUMP TO APPROPRIATE KEYWORD PROCESSING
                             ; ROUTINE

STAT10:  JSR    NTCOL        ; TRY TO RECOGNIZE A VALID NOTE OR REST
         LDA    NTERR        ; GET ERROR CODE
         BEQ    STAT11       ; SKIP AHEAD IF NO ERROR
         JSR    ER           ; SIGNAL ERROR IF NTCOL DETECTED ONE
         JMP    ESPEC        ; GO TO END OF SPECIFICATION PROCESSING

;        THE FOLLOWING CODE FIGURES OUT THE VOICE NUMBER THAT WILL BE
;        ASSUMED BY THE OBJECT CODE INTERPRETER WHEN THE MUSIC IS PLAYED

STAT11:  LDA    EVTBLD       ; TEST IF THE START OF A NEW EVENT
         BNE    STAT12       ; SKIP AHEAD IF NOT
         STA    VPPNT        ; START SCAN WITH VOICE 1
         DEC    EVTBLD       ; SET EVENT BEING BUILT FLAG
         LDA    VXDUR        ; MAKE SURE AT LEAST ONE VOICE IS ACTIVE
         AND    VXDUR+1      ; AND HAS A ZERO REMAINING DURATION
         AND    VXDUR+2
         AND    VXDUR+3
         BEQ    STAT12       ; SKIP AHEAD IF OK
         LDA    #$15         ; SIGNAL ER-15 IF NOT, EITHER NO VOICES
         JSR    ER           ; ACTIVE OR COMPILER ERROR
         JMP    KIMMON       ; ABORT COMPILATION

STAT12:  LDX    VPPNT        ; GET CURRENT VOICE NUMBER
STA122:  LDA    VXDUR,X      ; GET DURATION BYTE OF CURRENT VOICE
         BEQ    STA125       ; GO ASSIGN THIS NOTE SPEC TO IT IF ZERO
         INX                 ; INCREMENT TO NEXT VOICE NUMBER
         BNE    STA122       ; GO TRY IT

STA125:  LDA    NTVOIC       ; TEST IF A VOICE NUMBER GIVEN EXPLICITLY
         BEQ    STAT13       ; JUMP IF NOT
         DEC    NTVOIC       ; CHANGE EXPLICIT VOICE NUMBER TO ZERO ORG
         TXA                 ; COMPARE WITH IMPLICIT VOICE NUMBER
         CMP    NTVOIC
         BEQ    STAT13       ; JUMP AHEAD IF EQUAL, OK
         LDA    #7           ; SIGNAL ER 7 IF NOT EQUAL
         JSR    ER           ; AND CONTINUE USING ASSUMED VOICE NUMBER

STAT13:  LDA    NTPTC        ; TEST IF A REST WAS SPECIFIED
         BEQ    STA155       ; JUMP IF SO               .
         LDA    NTOCT        ; TEST IF EXPLICIT OCTAVE NUMBER GIVEN
         BNE    STAT14       ; JUMP IF SO
         LDA    VXOCT,X      ; IF NOT, USE LAST USED OCTAVE NUMBER
STAT14:  STA    VXOCT,X      ; UPDATE THE LAST USED OCTAVE NUMBER
         ASL    A            ; COMPUTE 12 TIMES THE OCTAVE NUMBER
         ASL    A
         STA    NTOCT
         ASL    A
         ADC    NTOCT
         ADC    NTPTC        ; ADD IN THE PITCH WITHIN THE OCTAVE
         ADC    #<(-12)      ; ADD IN CORRECTION FACTOR SO THAT C1=1
         CMP    #62          ; TEST IF NOTE IS IN RANGE
         BCC    STA145       ; JUMP IF OK
         LDA    #8           ; SIGNAL ER 8 IF OUT OF RANGE
         JSR    ER
         LDA    #61          ; AND USE HIGHEST POSSIBLE NOTE
STA145:  STA    NTPTC        ; SAVE COMPOSITE PITCH IN NTPTC
         LDA    VXABS,X      ; TEST IF ABSOLUTE PITCH REQUIRED
         BNE    STAT15       ; JUMP IF SO
         LDA    NTPTC        ; TEST IF DIFFERENCE BETWEEN PREVIOUS PITCH
         SEC                 ; AND NEXT PITCH IS SMALL ENOUGH FOR A
         SBC    VXPTC,X      ; SHORT NOTE SPECIFICATION
         CMP    #8
         BPL    STAT15       ; JUMP IF GREATER THAN +7
         CMP    #<(-7)
         BMI    STAT15       ; JUMP IF LESS THAN -7

         ASL    A            ; FORMAT A SHORT NOTE SPECIFICATION
         ASL    A
         ASL    A
         ASL    A            ; PITCH DISPLACEMENT IN UPPER HEX DIGIT
         ORA    NTDUR        ; DURATION IN LOWER HEX DIGIT
         JSR    CODOU        ; OUTPUT A BYTE OF OBJECT CODE
         JMP    STAT16       ; GO CLEANUP AFTER NOTE SPECIFICATION

STAT15:  LDA    #$60         ; FORMAT AN ABSOLUTE LONG NOTE SPEC
         JSR    CODOU        ; OUTPUT A 60 TO SIGNAL LONG NOTE SPEC
         LDA    NTPTC        ; GET COMPOSITE PITCH
         ASL    A            ; MULTIPLY IT BY 2
         JSR    CODOU        ; OUTPUT AS A BYTE OF OBJECT CODE
         LDA    VXWAV,X      ; GET WAVEFORM NUMBER FOR THE VOICE
         ASL    A            ; SHIFT LEFT 4 FOR LEFT HEX DIGIT
         ASL    A
         ASL    A
         ASL    A
         ORA    NTDUR        ; DURATION IN LOWER HEX DIGIT
         JSR    CODOU        ; OUTPUT AS A BYTE OF OBJECT CODE
         JMP    STAT16       ; GO CLEANUP AFTER NOTE SPEC

STA155:  LDA    #$80         ; FORMAT A REST SPEC
         ORA    NTDUR        ; OR IN DURATION
         JSR    CODOU        ; OUTPUT AS A BYTE OF OBJECT CODE
         JMP    STA165       ; SKIP PITCH UPDATE ON RESTS

STAT16:  LDA    NTPTC        ; CLEANUP AFTER NOTE SPEC
         STA    VXPTC,X      ; UPDATE CURRENT PITCH FOR THE VOICE
STA165:  LDA    #0           ; CLEAR FORCE ABSOLUTE PITCH FLAG
         STA    VXABS,X
         LDA    NTDURX       ; UPDATE DURATION FOR THE VOICE
         STA    VXDUR,X

;        DETERMINE IF A COMPLETE MUSICAL EVENT HAS BEEN BUILT, IF NOT
;        LEAVE VPPNT POINTING TO NEXT EXPIRED VOICE. IF SO, CLOSE OUT
;        THIS EVENT BY SUBTRACTING SHORTEST DURATION IN THIS EVENT
;        FROM THE DURATION OF EACH ACTIVE VOICE AND TURNING THE EVENT
;        BEING BUILT FLAG OFF

STAT17:  INX                 ; INCREMENT TO NEXT VOICE
         CPX    #4           ; TEST IF ALL VOICES SCANNED
         BEQ    STAT18       ; JUMP IF SO
         LDA    VXDUR,X      ; TEST IF THIS NEXT VOICE WILL REQUIRE A
                             ; NOTE SPEC
         BNE    STAT17       ; GO TO NEXT VOICE IF NOT
         STX    VPPNT        ; SAVE THE NEXT VOICE NUMBER
         BEQ    ESPEC        ; GO TO END OF SPEC PROCESSING

STAT18:  LDA    #$FF         ; SCAN THE VOICES TO FIND THE ONE WITH THE
STAT19:  CMP    VXDUR-1,X    ; SHORTEST DURATION
         BCC    STAT20
         LDA    VXDUR-1,X    ; UPDATE CURRENT SHORTEST IN A
STAT20:  DEX
         BNE    STAT19       ; LOOP UNTIL ALL 4 VOICES SCANNED

         STA    DUR          ; SCAN THE VOICES AGAIN AND SUBTRACT THE
STAT21:  LDA    VXDUR,X      ; SHORTEST DURATION FROM EACH ONE THAT IS
         CMP    #$FF         ; ACTIVE
         BEQ    STAT22       ; SKIP INACTIVE VOICES
         SEC
         SBC    DUR
         STA    VXDUR,X
STAT22:  INX
         CPX    #4
         BNE    STAT21

         LDA    #0           ; CLEAR THE EVENT BEING BUILT FLAG SINCE AN
         STA    EVTBLD       ; EVENT HAS JUST BEEN COMPILED
         BEQ    ESPEC        ; GO TO END OF SPEC PROCESSING

;        CLEANUP AFTER A KEYWORD OR NOTE SPECIFICATION

EXSPEC:  LDA    EVTBLD       ; TEST IF AN EXECUTABLE KEYWORD
                             ; SPECIFICATION PROCESSED IN THE MIDDLE OF
                             ; A MUSICAL EVENT
         BEQ    ESPEC        ; OK IF NOT; GO TO END OF SPEC PROCESSING
         LDA    #$10         ; GENERATE ER-10 IF SO
         JSR    ER
         LDA    #0           ; EMULATE INTERPRETER ACTION IN THIS
         STA    EVTBLD       ; SITUATION BY ABORTING CURRENT EVENT AND
                             ; STARTING A NEW ONE

ESPEC:   LDY    INBFPT       ; SCAN FOR A SEMICOLON OR CR
ESPEC1:  LDA    (INBFA),Y    ; GET CURRENT CHARACTER FROM INPUT BUFFER
         INY                 ; MOVE TO NEXT CHARACTER IN INPUT BUFFER
         CMP    #$0D         ; TEST IF ACR
         BEQ    ESTAT        ; GO TO END OF STATEMENT CLEANUP IF SO
         CMP    #';'         ; TEST IF A ";"
         BEQ    ESPEC2       ; SKIP AHEAD IF SO
         BNE    ESPEC1       ; GO TEST NEXT CHARACTER IF NOT
ESPEC2:  STY    INBFPT       ; UPDATE INPUT BUFFER POINTER
         JMP    STAT8        ; GO PROCESS CONTINUATION OF STATEMENT

;        CLEANUP AT END OF INPUT LINE

ESTAT:   LDA    #$0D         ; END LISTING LINE WITH A CR AND LF
         JSR    OUCH
         LDA    #$0A
         JSR    OUCH
         LDA    LIST         ; TEST IF LISTING ENABLED
         BEQ    ESTAT1       ; SKIP PRINT IF NOT
         JSR    OU           ; PRINT THE LISTING LINE IF LISTING ENABLED
ESTAT1:  LDA    ENDFLG       ; TEST IF END STATEMENT JUST PROCESSED
         BNE    ESTAT2
         JMP    STAT         ; GO PROCESS NEXT STATEMENT IF NOT
ESTAT2:  JMP    KIMMON       ; GO RETURN TO KIM MONITOR IF SO

;        NVCP DEFINE NUMBER OF VOICES, 1 ARGUMENT, RANGE 1-4

NVCP:    JSR    NNB          ; MOVE TO NEXT NON-BLANK CHARACTER
         JSR    GETARG       ; PROCESS THE NUMBER THAT IS NEXT EXPECTED
                             ; AND TEST IT FOR OVERFLOW ERRORS
         LDA    NBF          ; TEST FOR LEGITIMATE RANGE
         BEQ    ARGER        ; ZERO NOT ALLOWED
         CMP    #5           ; GREATER THAN 4 NOT ALLOWED
         BCS    ARGER
         LDA    #$50         ; FORMAT A SET NUMBER OF VOICES SPEC
         JSR    CODOU
         LDA    NBF
         JSR    CODOU
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING

;        ACTP ACTIVATE VOICES, MULTIPLE ARGS ALLOWED, RANGE 1-4

ACTP:    LDA    #$90         ; SET ACTIVATE VOICE CODE
         BNE    CTP

;        DCTP DEACTIVATE VOICES, MULTIPLE ARGS ALLOWED, RANGE 1-4

DCTP:    LDA    #$80         ; SET DEACTIVATE VOICE CODE

;        COMMON CODE FOR ACTIVATE AND DEACTIVATE VOICE KEYWORDS

CTP:     STA    CDSAV        ; SAVE ACTIVATE/DEACTIVATE CODE
CTP1:    JSR    GETARG       ; PROCESS THE NUMBER THAT IS NEXT EXPECTED
                             ; AND TEST IT FOR OVERFLOW ERRORS
         DEC    NBF          ; DECREMENT VOICE # FOR ZERO ORIGIN IN CODE
         LDA    NBF          ; TEST FOR LEGITIMATE RANGE
         CMP    #4           ; GREATER THAN 4 (BEFORE DECR) NOT ALLOWED
         BCS    ARGER
         LDA    CDSAV        ; FORMAT AN ACTIVATE/DEACTIVATE VOICE SPEC
         JSR    CODOU
         LDA    NBF
         JSR    CODOU
         LDX    NBF          ; GET VOICE NUMBER BACK
         LDA    CDSAV        ; GET ACTIVATE/DEACTIVATE CODE BACK
         EOR    #$90         ; FORM FF IF DCT, 00 IF ACT
         BEQ    CTP2
         LDA    #$FF
CTP2:    STA    VXDUR,X      ; UPDATE ACTIVE/INACTIVE STATUS OF VOICE
         LDY    INBFPT       ; TEST IF ARGUMENT TERMINATOR WAS A ,
         LDA    (INBFA),Y
         CMP    #','
         BEQ    CTP3         ; SKIP AHEAD IF SO
         JMP    EXSPEC       ; GO TO END OF SPEC PROCESSING IF NOT
CTP3:    INC    INBFPT       ; SKIP THE COMMA
         JMP    CTP1         ; AND GO PROCESS NEXT ARGUMENT

;        WAVP ASSIGN WAVEFORM TO VOICE, 2 ARGS, FIRST IS WAVEFORM
;        NUMBER RANGE 1-16, SECOND IS VOICE NUMBER, RANGE 1-4

WAVP:    JSR    GETARG       ; PROCESS THE NUMBER THAT IS NEXT EXPECTED
                             ; AND TEST IT FOR OVERFLOW ERRORS
         DEC    NBF          ; CONVERT WAVE # TO ZERO ORIGIN
         LDA    NBF          ; TEST FOR LEGITIMATE RANGE FOR WAVE NUMBER
         CMP    #16          ; GREATER THAN 16 (BEFORE DECR) NOT ALLOWED
         BCS    ARGER
         PHA                 ; SAVE WAVE NUMBER IF VALID
         INC    INBFPT       ; SKIP OVER COMMA ARGUMENT SEPARATOR
         JSR    GETARG       ; PROCESS THE EXPECTED VOICE NUMBER
         DEC    NBF          ; CONVERT VOICE # TO ZERO ORIGIN
         LDA    NBF          ; TEST FOR LEGITIMATE RANGE FOR VOICE NO.
         CMP    #4
         BCS    ARGER
         TAX                 ; PUT VOICE NUMBER IN X
         PLA                 ; GET WAVEFORM NUMBER BACK
         STA    VXWAV,X      ; UPDATE CURRENT WAVEFORM NUMBER IN VOICE
         LDA    #$FF
         STA    VXABS,X      ; SET FORCE ABSOLUTE PITCH SO THAT
                             ; NEXT NOTE GENERATED FOR THE VOICE WILL
                             ; UPDATE THE WAVEFORM NUMBER IN THE
                             ; INTERPRETER
         JMP    ESPEC        ; GO TO END OF SPEC PROCESSING

ARGER:   LDA    #1           ; COMMON ARGUMENT ERROR ROUTINE
         JSR    ER
         JMP    ESPEC        ; GO TO END OF SPEC PROCESSING

;        JSRP JUMP TO MUSICAL SUBROUTINE, 1 ARGUMENT, RANGE 1-255

JSRP:    LDA    #$20         ; SET JSR CODE
         BNE    JP           ; GO TO COMMON JMP/JSR CODE

;        JMP    UNCONDITIONAL JUMP, 1 ARGUMENT, RANGE 1-255

JMPP:    LDA    #$40         ; SET JMP CODE

;        COMMON JMP AND JSR CODE

JP:      STA    CDSAV        ; SAVE JSR/JMP CODE
         JSR    GETARG       ; EVALUATE ARGUMENT WHICH IS A NUMERICAL
         LDA    NBF          ; SYMBOL
         JSR    SYMSR        ; SEARCH SYMBOL TABLE FOR SYMBOL
         BCC    JP1          ; JUMP IF SYMBOL NOT FOUND
         LDA    CDSAV        ; GENERATE JSR/JMP SPEC IN OBJECT CODE
         JSR    CODOU
         LDY    #0           ; GET LOW BYTE OF SYMBOL VALUE
         LDA    (SYMTPT),Y
         SEC                 ; SUBTRACT CODE ORIGIN FROM IT FOR RELATIVE
         SBC    CODEA        ; ADDRESSING WITHIN OBJECT CODE
         PHP                 ; SAVE CARRY OUT STATUS
         JSR    CODOU        ; PUT LOW BYTE IN OBJECT CODE
         INY                 ; GET HIGH BYTE OF SYMBOL VALUE
         LDA    (SYMTPT),Y
         PLP                 ; RESTORE CARRY FROM LOW BYTE
         SBC    CODEA+1
         JSR    CODOU        ; PUT HIGH BYTE IN OBJECT CODE
         JMP    ESPEC        ; GO TO END OF SPEC PROCESSING
JP1:     LDA    #2           ; GENERATE UNDEFINED SYMBOL ERROR
         JSR    ER
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING

;        RTSP   RETURN FROM SUBROUTINE, NO ARGS

RTSP:    LDA    #$30         ; GENERATE A RTS SPEC IN THE OBJECT CODE
         JSR    CODOU
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING

;        ENDP   END OF SONG, NO ARGS

ENDP:    LDA    #0           ; GENERATE AN END SPEC IN THE OBJECT CODE
         JSR    CODOU
         LDA    #$FF         ; SET END FLAG
         STA    ENDFLG
         LDA    SUBSKP       ; TEST IF HANGING SUB LEFT OVER
         ORA    SUBSKP+1
         BEQ    ENDP1        ; SKIP AHEAD IF OK
         LDA    #$14         ; FORMAT ER-14 IF SO
         JSR    ER
ENDP1:   JMP    ESPEC        ; GO TO END OF SPEC PROCESSING

;        TPOP   SET TEMPO, 1 ARGUMENT

TPOP:    JSR    GETARG       ; PROCESS THE NUMBER THAT IS NEXT EXPECTED
                             ; AND TEST IT FOR OVERFLOW ERRORS
         BNE    ARGER        ; JUMP OUT IF OVERFLOW ERROR
         LDA    NBF          ; TEST FOR LEGITIMATE RANGE
         BEQ    ARGER        ; ZERO NOT ALLOWED
         LDA    #$10         ; GENERATE A CHANGE TEMPO SPEC IN CODE
         JSR    CODOU
         LDA    NBF          ; GET THE TEMPO ARGUMENT
         JSR    CODOU        ; *** USE IN RAW FORM *** TEMPORARY
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING

;        ABSP   FORCE ABSOLUTE PITCH UPDATE OF ALL VOICES, NO ARGS

ABSP:    LDX    #4           ; SET UP TO SET FORCE ABSOLUTE PITCH FLAG
         LDA    #$FF         ; IN ALL 4 VOICES
ABSP1:   STA    VXABS-1,X
         DEX
         BNE    ABSP1
         JMP    ESPEC        ; GO TO END OF SPEC PROCESSING

;        SUBP   DEFINE BEGINNING OF SUBROUTINE AREA

SUBP:    LDA    SUBSKP       ; TEST IF ALREADY A PENDING SUB
         ORA    SUBSKP+1
         BNE    SUBP1        ; GO TO ERROR IF SO
         LDA    #$40         ; FORMAT AN UNCONDITIONAL JUMP IN THE
         JSR    CODOU        ; OBJECT CODE
         LDA    CODEPT       ; SAVE PRESENT OBJECT CODE ADDRESS
         STA    SUBSKP       ; IN SUBSKP
         LDA    CODEPT+1
         STA    SUBSKP+1
         LDA    #0           ; PUT BLANK ADDRESS FIELD IN THE JUMP
         JSR    CODOU
         JSR    CODOU
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING
SUBP1:   LDA    #$12         ; GENERATE ER-13 IF ATTEMPT TO NEST SUB
         JSR    ER
         JMP    EXSPEC       ; DO NOTHING

;        ESBP   DEFINE END OF SUBROUTINE AREA

ESBP:    LDA    SUBSKP       ; TEST IF A PREVIOUS MATCHING "SUB"
         ORA    SUBSKP+1
         BEQ    ESBP1        ; JUMP TO ERROR IF NOT
         LDY    #0
         SEC                 ; SET CARRY FOR SUBTRACTION
         LDA    CODEPT       ; COMPUTE RELATIVE ADDRESS IN OBJECT CODE
         SBC    CODEA        ; AND FILL IN ADDRESS FIELD OF JUMP
         STA    (SUBSKP),Y   ; GENERATED BY "SUB" STATEMENT
         INY
         LDA    CODEPT+1
         SBC    CODEA+1
         STA    (SUBSKP),Y
         LDA    #0           ; CLEAR SUB DEFINITION
         STA    SUBSKP
         STA    SUBSKP+1
         JMP    EXSPEC       ; GO TO END OF EXECUTABLE SPEC PROCESSING
ESBP1:   LDA    #$13         ; GENERATE ER-12 IF ESB WITHOUT SUB
         JSR    ER
         JMP    EXSPEC       ; DO NOTHING

;        GETARG GET ARGUMENT, CHECK FOR OVERFLOW, A=0 IF OK, NOT ZERO
;        IF OVEFFLOW ERROR

GETARG:  JSR    NNB          ; FIRST MOVE TO NEXT NON-BLANK CHARACTER
         JSR    NCOL         ; COLLECT WHAT IS ASSUMED TO BE AN ARGUMENT
         LDA    NMERR        ; GET ERROR FLAG FROM NCOL
         RTS                 ; RETURN WITH ERROR CODE IN A

;        OULOC  OUTPUT LOCATION PLACE IN LISTING THE CURRENT VALUE OF
;               THE OBJECT CODE POINTER AS 4 DIGIT HEX FOLLOWED BY 2
;               BLANKS
;               NO REGISTERS BOTHERED

OULOC:   PHA                 ; SAVE A
         LDA    CODEPT+1     ; OUTPUT UPPER BYTE FIRST FOR NATURAL ORDER
         JSR    OUHX
         LDA    CODEPT       ; OUTPUT LOWER BYTE
         JSR    OUHX
         LDA    #' '         ; FOLLOW WITH 2 BLANKS
         JSR    OUCH
         JSR    OUCH
         PLA                 ; RESTORE A
         RTS                 ; RETURN


;        OUHX   OUTPUT CONTENTS OF A AS 2 HEX DIGITS
;        NO REGISTERS BOTHERED

OUHX:    PHA                 ; SAVE A
         LSR    A            ; RIGHT JUSTIFY HIGH 4 BITS
         LSR    A
         LSR    A
         LSR    A
         JSR    OUHX1        ; OUTPUT AS HEX DIGIT
         PLA                 ; RESTORE A
         PHA                 ; BUT KEEP IT ON THE STACK
         AND    #$0F         ; ISOLATE LOW 4 BITS AND OUTPUT AS HEX
         JSR    OUHX1
         PLA                 ; RESTORE A
         RTS                 ; RETURN

OUHX1:   CLC                 ; CONVERT 4 BIT NUMBER IN A TO ASCII HEX
         ADC    #'0'         ; DIGIT
         CMP    #'9'+1
         BMI    OUHX2
         ADC    #'A'-'0'-$A-1
OUHX2:   JSR    OUCH         ; OUTPUT THE ASCII HEX DIGIT
         RTS                 ; RETURN

;        OUCH   OUTPUT ASCII CHARACTER IN A WITH AUTOMATIC NEW LINE IF
;               LINE IS TOO LONG AND LISTING ENABLED
;               NO REGISTERS BOTHERED

OUCH:    PHA                 ; SAVE CHARACTER TO OUTPUT
         TXA                 ; AND INDEX X
         PHA
         TYA                 ; AND INDEX Y
         PHA
         LDY    OUBFPT       ; TEST IF 72 CHARACTERS ALREADY IN OUTPUT
         CPY    #72          ; BUFFER
         BCC    OUCH1        ; JUMP AHEAD IF LESS THAN 72
         LDA    #$00         ; PUT A CARRIAGE RETURN AND LINE FEED IN
         STA    (OUBFA),Y    ; THE OUTPUT BUFFER
         INY
         LDA    #$0A
         STA    (OUBFA),Y
         JSR    OU           ; PRINT THE CONTENTS OF THE OUTPUT BUFFER
         LDY    #0           ; REINITIALIZE OUTPUT BUFFER POINTER
         STY    OUBFPT
OUCH1:   TSX                 ; RESTORE CHARACTER TO BE OUTPUT
         LDA    $103,X
         STA    (OUBFA),Y    ; PUT IT IN THE OUTPUT BUFFER
         INC    OUBFPT       ; INCREMENT OUTPUT BUFFER POINTER
         PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

;        CODOU  CODE OUTPUT ADDS A BYTE OF OBJECT CODE TO THE OBJECT
;               CODE AREA IN MEMORY AND ALSO CONVERTS IT TO HEX AND ADDS
;               TWO HEX DIGITS FOLLOWED BY A BLANK TO THE LISTING OUTPUT
;               BUFFER.  GENERATES AN ERROR MESSAGE IF THE OBJECT CODE
;               AREA OVERFLOWS
;               ENTER WITH CODE BYTE IN A
;               PRESERVES ALL REGISTERS
;               ON CODE OVERFLOW ERROR, A NORMAL RETURN IS TAKEN SO ONCE
;               GENERATED, THE ERROR WILL REPEAT UNTIL THE COMPILATION
;               IS INTERRUPTED
;               NO REGISTERS BOTHERED

CODOU:   PHA                 ; SAVE REGISTERS
         TXA
         PHA
         TYA
         PHA
         LDA    CODELN+1     ; TEST IF OBJECT CODE AREA IS FULL
         CMP    CODECT+1
         BNE    CODOU1       ; JUMP IF NOT
         LDA    CODELN
         CMP    CODECT
         BNE    CODOU1       ; JUMP IF NOT
         LDA    #5           ; GENERATE ER 5 IF FULL
         JSR    ER
         JMP    CODOU2       ; GO RESTORE REGISTERS AND RETURN

CODOU1:  TSX                 ; GET THE CODE BYTE BACK
         LDA    $103,X
         LDY    #0           ; STORE CODE BYTE IN OBJECT CODE AREA
         STA    (CODEPT),Y
         JSR    OUHX         ; PRINT THE CODE BYTE IN HEX FOLLOWED BY A
         LDA    #' '         ; BLANK
         JSR    OUCH
         LDX    #CODEPT      ; INCREMENT OBJECT CODE POINTER
         JSR    DINC
         LDX    #CODECT      ; INCREMENT OBJECT CODE BYTE COUNT
         JSR    DINC
CODOU2:  PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

;        NTCOL  NOTE COLLECT ROUTINE
;               ENTER WITH INBFPT POINTING TO WHAT IS BELIEVED TO BE A
;               NOTE SPECIFICATION
;               EXIT IWTH THE FOLLOWING BASE PAGE VARIABLES SET:
;               NTERR - NTCOL ERROR CODE, O = NO ERROR
;               NTVOIC - VOICE NUMBER, ZERO IF NOT EXPLICITLY SPECIFIED
;               NTDUR - NOTE DURATION, 1-15 AS IN OBJECT CODE
;               NTPTC - NOTE PITCH, 0-12, C=1, B=12, REST=0
;               NTOCT - NOTE OCTAVE, 1-6, 0 IF NOT SPECIFIED
;               INBFPT POINTING TO CHARACTER FOLLOWING NOTE
;               SPECIFICATION, EITHER BLANK, ;, OR CR FOR NO ERROR
;               X AND Y REGISTERS PRESERVED

NTCOL:   TXA                 ; SAVE X AND Y REGISTERS
         PHA
         TYA
         PHA
         LDA    #0           ; INITIALIZE SOME RETURN ARGUMENTS
         STA    NTERR
         STA    NTVOIC
         STA    NTOCT
         STA    NTPTC
         LDY    INBFPT
         LDA    (INBFA),Y    ; GET CURRENT CHARACTER
         CMP    #'4'+1       ; TEST IF A VALID VOICE # DIGIT
         BCS    NTCOL1       ; JUMP IF NOT
         CMP    #'1'
         BCC    NTCOL1       ; JUMP IF NOT
         SBC    #'0'         ; IF A VALID VOICE # DIGIT, STORE IN BINARY
         STA    NTVOIC       ; AT NTVOIC
         INY                 ; SKIP OVER THE VOICE NUMBER DIGIT
NTCOL1:  LDA    (INBFA),Y    ; TEST IF VALID NOTE LETTER
         CMP    #'G'+1
         BCS    NTCOL5       ; JUMP IF NOT
         CMP    #'A'
         BCC    NTCOL5       ; JUMP IF NOT
         SBC    #'A'-1       ; CONVERT NOTE LETTER INTO A NUMBER; A=1,
         STA    NTPTC        ; G=7 AND MULTIPLY IT BY 3
         ASL    A
         ADC    NTPTC
         STA    NTPTC        ; PLACE IT IN NTPTC UNTIL SHARPS AND FLATS
                             ; EVALUATED
         INY                 ; SKIP OVER THE NOTE LETTER
         LDA    (INBFA),Y    ; GET NEXT CHARACTER
         CMP    #'#'         ; TEST IF A SHARP
         BNE    NTCOL2       ; JUMP IF NOT
         INC    NTPTC        ; INCREMENT NTPTC IF SHARP
         BNE    NTCOL3
NTCOL2:  CMP    #'@'         ; TEST IF FLAT
         BNE    NTCOL4       ; JUMP IF NOT
         DEC    NTPTC        ; DECREMENT NTPTC IF FLAT
NTCOL3:  INY                 ; SKIP OVER # OR @ IF PRESENT
NTCOL4:  LDX    NTPTC        ; CONVERT VALUE IN NTPTC INTO FINAL FORM
         LDA    NTPTCT-2,X
         STA    NTPTC
         LDA    (INBFA),Y    ; TEST IF VALID OCTAVE DIGIT PRESENT
         CMP    #'6'+1
         BCS    NTCOL7       ; JUMP IF NOT
         CMP    #'1'
         BCC    NTCOL7       ; JUMP IF NOT
         SBC    #'0'         ; CONVERT THE DIGIT TO BINARY AND PLACE IN
         STA    NTOCT        ; NTOCT
         INY                 ; SKIP OVER THE OCTAVE DIGIT
         JMP    NTCOL7       ; GO TO DURATION INTERPRET
NTCOL5:  CMP    #'R'         ; TEST IF REST SPECIFICATION
         BEQ    NTCOL6       ; JUMP IF SO
NTCOL0:  LDA    #6           ; ER 6 IF NOT
         STA    NTERR
         JMP    NTCOLD       ; GO RETURN
NTCOL6:  INY                 ; SKIP OVER THE R IF PRESENT, NTPTC WILL BE
                             ; ZERO SIGNIFYING A REST

NTCOL7:  LDX    #1           ; SCAN NTDURT TO DETERMINE IF CURRENT CHAR.
NTCOL8:  LDA    NTDURT-1,X   ; IS A VAILD DURATION
         BEQ    NTCOLE       ; JUMP OUT IF END OF TABLE, ILLEGAL DUR.
         CMP    (INBFA),Y
         BEQ    NTCOL9       ; JUMP OUT IF MATCH
         INX                 ; INDEX TO NEXT TABLE ENTRY
         BNE    NTCOL8       ; LOOP TO TRY NEXT ENTRY
NTCOL9:  TXA                 ; GET 3 TIMES X AND PUT IN NTDUR
         STA    NTDUR
         ASL    A
         ADC    NTDUR
         STA    NTDUR
         INY                 ; SKIP OVER THE DURATION LETTER
         LDA    (INBFA),Y    ; GET CURRENT CHARACTER
         CMP    #'.'         ; TEST IF DURATION MODIFIER "."
         BNE    NTCOLA       ; JUMP IF NOT
         DEC    NTDUR        ; DECREMENT NTDUR IF A .
         BNE    NTCOLB
NTCOLA:  CMP    #'3'         ; TEST IF DURATION MODIFIER "3" (TRIPLET)
         BNE    NTCOLC       ; JUMP IF NOT
         INC    NTDUR        ; INCREMENT NTDUR IF A 3
NTCOLB:  INY                 ; SKIP OVER THE "." OR "3" IF PRESENT

NTCOLC:  LDX    NTDUR        ; CONVERT NTDUR INTO FINAL OBJECT FORM
         LDA    NTDRT1-2,X
         BEQ    NTCOLE       ; JUMP IF ILLEGAL DURATION
         STA    NTDUR
         TAX                 ; CONVERT NTDUR TO ABSOLUTE TIME VALUE FOR
         LDA    NTDRT2-1,X   ; COMPILER
         STA    NTDURX
         LDA    (INBFA),Y    ; TEST IF VALID NOTE SPEC TERMINATOR
         CMP    #' '         ; BLANK
         BEQ    NTCOLD
         CMP    #';'         ; SEMICOLON
         BEQ    NTCOLD
         CMP    #$0D         ; CARRIAGE RETURN
         BNE    NTCOL0       ; SIGNAL ER 6 IF NOT VALID TERMINATOR
NTCOLD:  STY    INBFPT       ; UPDATE INBFPT
         PLA                 ; RESTORE X AND Y
         TAY
         PLA
         TAX
         RTS                 ; RETURN

NTCOLE:  LDA    #9           ; SIGNAL ER 9 IF ILLEGAL DURATION
         STA    NTERR
         BNE    NTCOLD       ; GO RETURN

;        NOTE PITCH TRANSLATE TABLE

NTPTCT:  .BYTE  9,10,11      ; A@ A A#
         .BYTE  11,12,1      ; B@ B B#
         .BYTE  12,1,2       ; C@ C C#
         .BYTE  2,3,4        ; D@ D D#
         .BYTE  4,5,6        ; E@ E E#
         .BYTE  5,6,7        ; F@ F F#
         .BYTE  7,8,9        ; G@ G G#

;        DURATION TRANSLATE TABLES

;        LIST OF VALID DURATION LETTERS
NTDURT:  .BYTE  'W','H','Q'  ; WHOLE, HALF, QUARTER
         .BYTE  'E','S','T'  ; EIGHTH, SIXTEENTH, THIRTY-SECOND
         .BYTE  0            ; END OF TABLE MARKER

;        TRANSLATE DURATION LETTER AND MODIFIER TO DURATION CODE
NTDRT1:  .BYTE  0,1,0        ; W. (ILLEGAL)  W   W3 (ILLEGAL)
         .BYTE  2,3,5        ; H.   H   H3
         .BYTE  4,6,8        ; Q.   Q   Q3
         .BYTE  7,9,11       ; E.   E   E3
         .BYTE  10,12,14     ; S.   S   S3
         .BYTE  13,15,0      ; T.   T   T3 (ILLEGAL)

;        TRANSLATE DURATION CODE TO ABSOLUTE TIME VALUE
NTDRT2:  .BYTE  192,144,96   ; W   H.  W3
         .BYTE  72,64,48     ; Q.  H3  Q
         .BYTE  36,32,24     ; E.  Q3  E
         .BYTE  18,16,12     ; S.  E3  S
         .BYTE  9,8,6        ; T.  S3  T

;        NCOL   NUMBER COLLECT
;               ENTER WITH INBFPT POINTING TO A DIGIT.
;               EXIT WITH NMERR=0, NUMBER VALUE IN NBF, AND INBFPT
;               POINTING TO TERMINATOR (FIRST NON-DIGIT) IF A VALID
;               NUMBER FOUND (0-255).
;               EXIT WITH NMERR=ER1, NBF UNDEFINED, AND INBFPT POINTING
;               TO TERMINATOR IF OVERFLOW.
;               NO REGISTERS BOTHERED

NCOL:    PHA                 ; SAVE A
         TYA                 ; SAVE Y
         PHA
         LDA    #0
         STA    NBF          ; CLEAR NUMBER BEING FORMED
         STA    NMERR        ; CLEAR OVERFLOW FLAG
         LDY    INBFPT
NCOL1:   LDA    (INBFA),Y    ; GET CHARACTER FROM INPUT BUFFER
         CMP    #'0'
         BCC    NCOL3        ; BRANCH IF NOT A DIGIT
         CMP    #'9'+1
         BCS    NCOL3        ; BRANCH IF NOT A DIGIT
         LDA    NBF          ; IF A DIGIT, FIRST MULTIPLY NBF BY 10
         ASL    A            ; WITH OVERFLOW CHECK
         BCS    NCOL4
         ASL    A
         BCS    NCOL4
         ADC    NBF
         BCS    NCOL4
         ASL    A
         BCS    NCOL4
         STA    NBF
         LDA    (INBFA),Y    ; GET NEW DIGIT
         ADC    #<(-'0')     ; CONVERT TO BINARY
         CLC
         ADC    NBF          ; ADD TO NBF WITH OVERFLOW CHECK
         BCS    NCOL4
         STA    NBF
NCOL2:   INY                 ; GO TO NEXT INPUT CHARACTER
         JMP    NCOL1        ; GO FOR NEXT DIGIT

NCOL3:   STY    INBFPT       ; UPDATE INBFPT
         PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         RTS                 ; RETURN

NCOL4:   LDA    #1           ; SET OVERFLOW ERROR CODE
         STA    NMERR
         JMP    NCOL2        ; CONTINUE SCANNING FOR END OF NUMBER

;        KWCOL  KEYWORD COLLECT AND MATCH
;               ENTER WITH INBFPT POINTING TO A NON-BLANK CHARACTER.
;               ROUTINE LOOKS AT THIS CHARACTER AND THE NEXT TWO.
;               IF THE 3 CHARACTERS MATCH A KEYWORD, RETURN WITH X
;               POINTING TO JUMP ADDRESS IN KEYWORD TABLE ENTRY AND C=1
;               AND INBFPT POINTING TO CHARACTER FOLLOWING THE KEYWORD.
;               IF NO MATCH, RETURN WITH C=0 AND INBFPT UNCHANGED.
;               PRESERVES Y

KWCOL:   TYA                 ; SAVE Y
         PHA
         LDX    #0           ; ZERO POINTER INTO KEYWORD TABLE
KWCOL1:  STX    KWTP
         LDA    KWTAB,X      ; TEST IF AT END OF KEYWORD TABLE
         BNE    KWCOL3       ; JUMP IF NOT
         CLC                 ; CLEAR CARRY TO INDICATE FAILURE TO FIND
         BCC    KWCOL5       ; A MATCH AND RETURN

KWCOL3:  LDA    #3           ; INITIALIZE MATCH COUNT
         STA    KWMC
         LDY    INBFPT       ; GET POINTER TO CURRENT INPUT CHARACTER
KWCOL4:  LDA    (INBFA),Y    ; TEST IF MATCH BETWEEN KEYWORD TABLE ENTRY
         CMP    KWTAB,X      ; AND INPUT BUFFER CHARACTER
         BNE    KWCOL6       ; JUMP IF NO MATCH
         INX                 ; IF MATCH, INCREMENT INDICES
         INY
         DEC    KWMC         ; TEST IF 3 CHARACTERS MATCHED
         BNE    KWCOL4       ; GO MATCH NEXT IF NOT
         STY    INBFPT       ; IF MATCH, UPDATE INBFPT
         SEC                 ; SET CARRY TO INDICATE MATCH FOUND
KWCOL5:  PLA                 ; RESTORE Y
         TAY
         RTS                 ; RETURN

KWCOL6:  LDA    KWTP         ; UPDATE KWTP TO POINT TO NEXT KEYWORD IN
         CLC                 ; TABLE
         ADC    #5
         TAX
         JMP    KWCOL1       ; GO TRY TO MATCH NEXT KEYWORD

;        KEYWORD TABLE

KWTAB:   .BYTE  'N','V','C'  ; DEFINE NUMBER OF VOICES
         .WORD  NVCP
         .BYTE  'A','C','T'  ; ACTIVATE VOICES
         .WORD  ACTP
         .BYTE  'D','C','T'  ; DEACTIVATE VOICES
         .WORD  DCTP
         .BYTE  'W','A','V'  ; ASSIGN WAVEFORM
         .WORD  WAVP
         .BYTE  'J','S','R'  ; JUMP TO SUBROUTINE
         .WORD  JSRP
         .BYTE  'J','M','P'  ; JUMP
         .WORD  JMPP
         .BYTE  'R','T','S'  ; RETURN FROM SUBROUTINE
         .WORD  RTSP
         .BYTE  'T','P','O'  ; SET TEMPO
         .WORD  TPOP
         .BYTE  'E','N','D'  ; END OF SONG
         .WORD  ENDP
         .BYTE  'A','B','S'  ; FORCE ABSOLUTE PITCH UPDATE
         .WORD  ABSP
         .BYTE  'S','U','B'  ; DEFINE BEGINNING OF SUBROUTINE AREA
         .WORD  SUBP
         .BYTE  'E','S','B'  ; DEFINE END OF SUBROUTINE AREA
         .WORD  ESBP
         .BYTE  0            ; END OF TABLE MARKER

;        SYMSR  SYMBOL TABLE SEARCH
;               ENTER WITH SYMBOL TO SEARCH FOR IN A RANGE OF 1-255.
;               EXIT WITH SYMTPT POINTING TO LOW BYTE OF SYMBOL VALUE
;               AND C=1 IF SYMBOL IS FOUND, SYMTPT POINTING TO END OF
;               SYMBOL TABLE AND C=0 IF NOT FOUND.  NO REGISTERS
;               AFFECTED.

SYMSR:   PHA                 ; SAVE A
         TXA                 ; SAVE X
         PHA
         TYA                 ; SAVE Y
         PHA
         LDA    SYMTA        ; COPY SYMTA INTO SYMTPT
         STA    SYMTPT
         LDA    SYMTA+1
         STA    SYMTPT+1
         LDY    #0           ; ZERO Y FOR STRAIGHT INDIRECT
SYMSR0:  LDA    (SYMTPT),Y   ; TEST IF AT END OF SYMBOL TABLE
         BNE    SYMSR1       ; BRANCH IF NOT
         CLC                 ; CLEAR CARRY TO INDICATE SEARCH FAILURE
         BCC    SYMSR2       ; GO RESTORE REGISTERS AND RETURN
SYMSR1:  TSX                 ; LOAD STACK POINTER INTO X TO MAKE SAVED
                             ; SYMBOL ACCESSABLE
         CMP    $103,X       ; COMPARE WITH SYMBOL BEING SEARCHED FOR
         BNE    SYMSR3       ; BRANCH IF NO MATCH
         LDX    #SYMTPT      ; INCREMENT SYMTPT TO POINT TO VALUE IF
         JSR    DINC         ; MATCH
         SEC                 ; SET CARRY TO INDICATE SEARCH SUCCESS
SYMSR2:  PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

SYMSR3:  LDX    #SYMTPT      ; INCREMENT SYMTPT BY 3 TO POINT TO NEXT
         JSR    DINC         ; SYMBOL
         JSR    DINC
         JSR    DINC
         JMP    SYMSR0       ; GO CHECK NEXT SYMBOL

;        SYMAD  SYMBOL TABLE ADD ROUTINE
;               ENTER WITH SYMBOL TO ADD IN A, VALUE OF SYMBOL IN CODEPT
;               SYMTPT POINTING TO END OF SYMBOL TABLE
;               RETURN WITH C=1 FOR SUCCESSFUL ADD, C=0 FOR SYMBOL TABLE
;               OVERFLOW.

SYMAD:   PHA                 ; SAVE A
         TXA                 ; SAVE X
         PHA
         TYA                 ; SAVE Y
         PHA
         LDA    SYMTCT       ; TEST FOR TABLE OVERFLOW
         CMP    SYMTLN
         BCC    SYMAD2       ; JUMP IF OK
         CLC                 ; CLEAR CARRY TO INDICATE UNSUCCESSFUL ADD
SYMAD1:  PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

SYMAD2:  INC    SYMTCT       ; INCREMENT SYMBOL COUNT
         LDY    #0           ; ZERO Y FOR STRAIGHT INDIRECT
         TSX                 ; COPY STACK POINTER TO X TO MAKE SAVED
                             ; SYMBOL ACCESSABLE
         LDA    $103,X       ; ADD THE SYMBOL TO THE TABLE
         STA    (SYMTPT),Y
         LDX    #SYMTPT      ; INCREMENT SYMBOL TABLE POINTER
         JSR    DINC
         LDA    CODEPT       ; ADD LOW VALUE TO TABLE
         STA    (SYMTPT),Y
         JSR    DINC
         LDA    CODEPT+1     ; ADD HIGH VALUE TO TABLE
         STA    (SYMTPT),Y
         JSR    DINC
         LDA    #0           ; SET END OF TABLE FLAG
         STA    (SYMTPT),Y
         SEC                 ; SET CARRY TO INDICATE SUCCESSFUL ADD
         BCS    SYMAD1       ; GO RESTORE REGISTERS AND RETURN

;        NNB    NEXT NON-BLANK SEARCH
;               ENTER WITH INBFPT POINTING TO FIRST BYTE TO BE SEARCHED.
;               EXIT WITH INBFPT POINTING TO FIRST NON-BLANK CHARACTER
;               ALL REGISTERS PRESERVED

NNB:     PHA                 ; SAVE A AND Y
         TYA
         PHA
         LDY    INBFPT       ; GET CURRENT CHARACTER POINTER
NNB1:    LDA    (INBFA),Y    ; GET CURRENT CHARACTER
         CMP    #' '         ; TEST IF A BLANK
         BNE    NNB2         ; JUMP IF NOT
         INY                 ; IF A BLANK, GO TO NEXT CHARACTER
         BNE    NNB1         ; GO TEST NEXT CHARACTER
NNB2:    STY    INBFPT       ; RETURN WITH CHARACTER IN A WHEN NON-BLANK
         PLA                 ; FOUND
         TAY                 ; RESTORE Y AND A
         PLA
         RTS                 ; RETURN


;        DINC   DOUBLE INCREMENT
;               ENTER WITH X POINTING TO THE LOW BYTE OF THE WORD TO
;               INCREMENT, HIGH BYTE IS AT X+1 (WORD IN BASE PAGE)
;               NO REGISTERS AFFECTED

DINC:    INC    0,X          ; INCREMENT LOW BYTE
         BNE    DINC1        ; SKIP AHEAD IF NO CARRY OUT
         INC    1,X
DINC1:   RTS                 ; RETURN



;        LINKS TO USER SUPPLIED INPUT AND OUTPUT ROUTINES

IN:      JMP    (INP)        ; INPUT A LINE TO INPUT BUFFER
OU:      JMP    (OUT)        ; OUTPUT A LINE FROM OUTPUT BUFFER
INIT:    JMP    (INPINT)     ; INITIALIZE INPUT ROUTINE IN PREP FOR
                             ; FIRST LINE
OUIT:    JMP    (OUTINT)     ; INITIALIZE OUTPUT ROUTINE IN PREP FOR
                             ; FIRST LINE

;        ER     ERROR ROUTINE
;               IF LISTING IS ENABLED, A MESSAGE OF THE FORM "ER X" IS
;               INSERTED IN THE OBJECT CODE LISTING.
;               IF LISTING IS DISABLED, A CALL TO A USER SUPPLIED ERROR
;               ROUTINE IS PERFORMED WITH THE ERROR CODE IN A
;               NO REGISTERS ARE BOTHERED

ER:      PHA                 ; SAVE THE ERROR CODE
         TXA                 ; SAVE OTHER REGISTERS IN CASE USER ERROR
         PHA                 ; ROUTINE USES THEM
         TYA
         PHA
         TSX                 ; COPY STACK POINTER INTO X SO THAT ERROR
                             ; CODE MAY BE RETRIEVED
         LDA    LIST         ; TEST IF LISTING ENABLED
         BEQ    ER2          ; JUMP AHEAD TO USER ERROR ROUTINE IF NOT
         LDA    #'E'         ; PUT ER- IN LISTING
         JSR    OUCH
         LDA    #'R'
         JSR    OUCH
         LDA    #'-'
         JSR    OUCH
         LDA    $103,X       ; RESTORE ERROR CODE
         JSR    OUHX         ; OUTPUT AS TWO HEX DIGITS
         LDA    #' '         ; FOLLOWED BY A BLANK
         JSR    OUCH
ER1:     PLA                 ; RESTORE REGISTERS
         TAY
         PLA
         TAX
         PLA
         RTS                 ; RETURN

ER2:     LDA    $103,X       ; GET ERROR CODE BACK
         JSR    ER3
         JMP    ER1          ; GO RESTORE REGISTERS AND RETURN

ER3:     JMP    (ERR)        ; GO TO USER SUPPLIED ERROR ROUTINE


CMPEND:  .END
